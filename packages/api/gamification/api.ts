/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ArcadeAuctionsOutputsGetRoundID
 */
export interface ArcadeAuctionsOutputsGetRoundID {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ArcadeAuctionsOutputsGetRoundID
     */
    'round_id': string;
}
/**
 * 
 * @export
 * @interface ArcadeRoomExtensionsOutputsGetRoundID
 */
export interface ArcadeRoomExtensionsOutputsGetRoundID {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ArcadeRoomExtensionsOutputsGetRoundID
     */
    'round_id': string;
}
/**
 * 
 * @export
 * @interface CreateExtensionCommitmentInput
 */
export interface CreateExtensionCommitmentInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateExtensionCommitmentInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateExtensionCommitmentInput
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateExtensionCommitmentInput
     */
    'round_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateExtensionCommitmentInput
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface CreateTokenTransactionInput
 */
export interface CreateTokenTransactionInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateTokenTransactionInput
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTokenTransactionInput
     */
    'quantity': number;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreateTokenTransactionInput
     */
    'transaction_type': TransactionType;
    /**
     * 
     * @type {TransactionReason}
     * @memberof CreateTokenTransactionInput
     */
    'reason': TransactionReason;
}


/**
 * 
 * @export
 * @interface ExtensionCommitment
 */
export interface ExtensionCommitment {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ExtensionCommitment
     */
    'id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ExtensionCommitment
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ExtensionCommitment
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ExtensionCommitment
     */
    'token_ledger_id': string;
    /**
     * 
     * @type {number}
     * @memberof ExtensionCommitment
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ExtensionCommitment
     */
    'created_date'?: string;
}
/**
 * 
 * @export
 * @interface GetCommitmentTotalOutput
 */
export interface GetCommitmentTotalOutput {
    /**
     * 
     * @type {number}
     * @memberof GetCommitmentTotalOutput
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface GetExtensionCacheOutput
 */
export interface GetExtensionCacheOutput {
    /**
     * 
     * @type {number}
     * @memberof GetExtensionCacheOutput
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExtensionCacheOutput
     */
    'price'?: number;
    /**
     * 
     * @type {Array<ExtensionCommitment>}
     * @memberof GetExtensionCacheOutput
     */
    'commitments': Array<ExtensionCommitment>;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof GetExtensionCacheOutput
     */
    'round_id'?: string;
}
/**
 * 
 * @export
 * @interface GetExtensionPriceOutput
 */
export interface GetExtensionPriceOutput {
    /**
     * 
     * @type {number}
     * @memberof GetExtensionPriceOutput
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HighestBid
 */
export interface HighestBid {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof HighestBid
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof HighestBid
     */
    'user_id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof HighestBid
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof HighestBid
     */
    'round_id': string;
    /**
     * 
     * @type {number}
     * @memberof HighestBid
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof HighestBid
     */
    'created_date'?: string;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface PlaceBidInput
 */
export interface PlaceBidInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PlaceBidInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PlaceBidInput
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PlaceBidInput
     */
    'round_id': string;
    /**
     * 
     * @type {number}
     * @memberof PlaceBidInput
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface SelectHighestBidderInput
 */
export interface SelectHighestBidderInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof SelectHighestBidderInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof SelectHighestBidderInput
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof SelectHighestBidderInput
     */
    'round_id': string;
}
/**
 * 
 * @export
 * @interface TokenCountOutput
 */
export interface TokenCountOutput {
    /**
     * 
     * @type {number}
     * @memberof TokenCountOutput
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface TokenLedger
 */
export interface TokenLedger {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TokenLedger
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TokenLedger
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof TokenLedger
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof TokenLedger
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenTransaction
 */
export interface TokenTransaction {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TokenTransaction
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TokenTransaction
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof TokenTransaction
     */
    'quantity': number;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TokenTransaction
     */
    'token_ledger_id': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TokenTransaction
     */
    'transaction_type': TransactionType;
    /**
     * 
     * @type {TransactionReason}
     * @memberof TokenTransaction
     */
    'reason': TransactionReason;
    /**
     * 
     * @type {boolean}
     * @memberof TokenTransaction
     */
    'is_active'?: boolean;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TransactionReason = {
    Refund: 'refund',
    Extension: 'extension',
    Auction: 'auction',
    Withdrawal: 'withdrawal',
    Deposit: 'deposit',
    Reward: 'reward',
    Adjustment: 'adjustment'
} as const;

export type TransactionReason = typeof TransactionReason[keyof typeof TransactionReason];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Credit: 'credit',
    Debit: 'debit'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface VerifyAppleTransactionInput
 */
export interface VerifyAppleTransactionInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyAppleTransactionInput
     */
    'transaction_id': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyAppleTransactionInput
     */
    'receipt': string;
    /**
     * 
     * @type {boolean}
     * @memberof VerifyAppleTransactionInput
     */
    'is_sandbox'?: boolean;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof VerifyAppleTransactionInput
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface VerifyGoogleTransactionInput
 */
export interface VerifyGoogleTransactionInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyGoogleTransactionInput
     */
    'purchase_token': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyGoogleTransactionInput
     */
    'product_id': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyGoogleTransactionInput
     */
    'package_name': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof VerifyGoogleTransactionInput
     */
    'user_id': string;
}

/**
 * AuctionsApi - axios parameter creator
 * @export
 */
export const AuctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Auction Round
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuctionRoundAuctionsRoomsRoomIdRoundPost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createAuctionRoundAuctionsRoomsRoomIdRoundPost', 'roomId', roomId)
            const localVarPath = `/auctions/rooms/{room_id}/round/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Highest Bid
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighestBidAuctionsRoomsRoomIdHighestBidGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getHighestBidAuctionsRoomsRoomIdHighestBidGet', 'roomId', roomId)
            const localVarPath = `/auctions/rooms/{room_id}/highest-bid/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Round Id
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoundIdAuctionsRoomsRoomIdRoundIdGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoundIdAuctionsRoomsRoomIdRoundIdGet', 'roomId', roomId)
            const localVarPath = `/auctions/rooms/{room_id}/round-id/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place Bid
         * @param {PlaceBidInput} placeBidInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBidAuctionsRoomsPlaceBidPost: async (placeBidInput: PlaceBidInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeBidInput' is not null or undefined
            assertParamExists('placeBidAuctionsRoomsPlaceBidPost', 'placeBidInput', placeBidInput)
            const localVarPath = `/auctions/rooms/place-bid/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeBidInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select Highest Bidder
         * @param {SelectHighestBidderInput} selectHighestBidderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectHighestBidderAuctionsRoomsSelectHighestBidderPost: async (selectHighestBidderInput: SelectHighestBidderInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectHighestBidderInput' is not null or undefined
            assertParamExists('selectHighestBidderAuctionsRoomsSelectHighestBidderPost', 'selectHighestBidderInput', selectHighestBidderInput)
            const localVarPath = `/auctions/rooms/select-highest-bidder/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(selectHighestBidderInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuctionsApi - functional programming interface
 * @export
 */
export const AuctionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuctionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Auction Round
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuctionRoundAuctionsRoomsRoomIdRoundPost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuctionRoundAuctionsRoomsRoomIdRoundPost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuctionsApi.createAuctionRoundAuctionsRoomsRoomIdRoundPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Highest Bid
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighestBidAuctionsRoomsRoomIdHighestBidGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HighestBid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHighestBidAuctionsRoomsRoomIdHighestBidGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuctionsApi.getHighestBidAuctionsRoomsRoomIdHighestBidGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Round Id
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoundIdAuctionsRoomsRoomIdRoundIdGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArcadeAuctionsOutputsGetRoundID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoundIdAuctionsRoomsRoomIdRoundIdGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuctionsApi.getRoundIdAuctionsRoomsRoomIdRoundIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Place Bid
         * @param {PlaceBidInput} placeBidInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeBidAuctionsRoomsPlaceBidPost(placeBidInput: PlaceBidInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeBidAuctionsRoomsPlaceBidPost(placeBidInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuctionsApi.placeBidAuctionsRoomsPlaceBidPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Select Highest Bidder
         * @param {SelectHighestBidderInput} selectHighestBidderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selectHighestBidderAuctionsRoomsSelectHighestBidderPost(selectHighestBidderInput: SelectHighestBidderInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selectHighestBidderAuctionsRoomsSelectHighestBidderPost(selectHighestBidderInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuctionsApi.selectHighestBidderAuctionsRoomsSelectHighestBidderPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuctionsApi - factory interface
 * @export
 */
export const AuctionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuctionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Auction Round
         * @param {AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuctionRoundAuctionsRoomsRoomIdRoundPost(requestParameters: AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createAuctionRoundAuctionsRoomsRoomIdRoundPost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Highest Bid
         * @param {AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighestBidAuctionsRoomsRoomIdHighestBidGet(requestParameters: AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<HighestBid> {
            return localVarFp.getHighestBidAuctionsRoomsRoomIdHighestBidGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Round Id
         * @param {AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoundIdAuctionsRoomsRoomIdRoundIdGet(requestParameters: AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ArcadeAuctionsOutputsGetRoundID> {
            return localVarFp.getRoundIdAuctionsRoomsRoomIdRoundIdGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place Bid
         * @param {AuctionsApiPlaceBidAuctionsRoomsPlaceBidPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBidAuctionsRoomsPlaceBidPost(requestParameters: AuctionsApiPlaceBidAuctionsRoomsPlaceBidPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.placeBidAuctionsRoomsPlaceBidPost(requestParameters.placeBidInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select Highest Bidder
         * @param {AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectHighestBidderAuctionsRoomsSelectHighestBidderPost(requestParameters: AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.selectHighestBidderAuctionsRoomsSelectHighestBidderPost(requestParameters.selectHighestBidderInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAuctionRoundAuctionsRoomsRoomIdRoundPost operation in AuctionsApi.
 * @export
 * @interface AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPostRequest
 */
export interface AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPost
     */
    readonly roomId: string
}

/**
 * Request parameters for getHighestBidAuctionsRoomsRoomIdHighestBidGet operation in AuctionsApi.
 * @export
 * @interface AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGetRequest
 */
export interface AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getRoundIdAuctionsRoomsRoomIdRoundIdGet operation in AuctionsApi.
 * @export
 * @interface AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGetRequest
 */
export interface AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGet
     */
    readonly roomId: string
}

/**
 * Request parameters for placeBidAuctionsRoomsPlaceBidPost operation in AuctionsApi.
 * @export
 * @interface AuctionsApiPlaceBidAuctionsRoomsPlaceBidPostRequest
 */
export interface AuctionsApiPlaceBidAuctionsRoomsPlaceBidPostRequest {
    /**
     * 
     * @type {PlaceBidInput}
     * @memberof AuctionsApiPlaceBidAuctionsRoomsPlaceBidPost
     */
    readonly placeBidInput: PlaceBidInput
}

/**
 * Request parameters for selectHighestBidderAuctionsRoomsSelectHighestBidderPost operation in AuctionsApi.
 * @export
 * @interface AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPostRequest
 */
export interface AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPostRequest {
    /**
     * 
     * @type {SelectHighestBidderInput}
     * @memberof AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPost
     */
    readonly selectHighestBidderInput: SelectHighestBidderInput
}

/**
 * AuctionsApi - object-oriented interface
 * @export
 * @class AuctionsApi
 * @extends {BaseAPI}
 */
export class AuctionsApi extends BaseAPI {
    /**
     * 
     * @summary Create Auction Round
     * @param {AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuctionsApi
     */
    public createAuctionRoundAuctionsRoomsRoomIdRoundPost(requestParameters: AuctionsApiCreateAuctionRoundAuctionsRoomsRoomIdRoundPostRequest, options?: RawAxiosRequestConfig) {
        return AuctionsApiFp(this.configuration).createAuctionRoundAuctionsRoomsRoomIdRoundPost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Highest Bid
     * @param {AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuctionsApi
     */
    public getHighestBidAuctionsRoomsRoomIdHighestBidGet(requestParameters: AuctionsApiGetHighestBidAuctionsRoomsRoomIdHighestBidGetRequest, options?: RawAxiosRequestConfig) {
        return AuctionsApiFp(this.configuration).getHighestBidAuctionsRoomsRoomIdHighestBidGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Round Id
     * @param {AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuctionsApi
     */
    public getRoundIdAuctionsRoomsRoomIdRoundIdGet(requestParameters: AuctionsApiGetRoundIdAuctionsRoomsRoomIdRoundIdGetRequest, options?: RawAxiosRequestConfig) {
        return AuctionsApiFp(this.configuration).getRoundIdAuctionsRoomsRoomIdRoundIdGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place Bid
     * @param {AuctionsApiPlaceBidAuctionsRoomsPlaceBidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuctionsApi
     */
    public placeBidAuctionsRoomsPlaceBidPost(requestParameters: AuctionsApiPlaceBidAuctionsRoomsPlaceBidPostRequest, options?: RawAxiosRequestConfig) {
        return AuctionsApiFp(this.configuration).placeBidAuctionsRoomsPlaceBidPost(requestParameters.placeBidInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select Highest Bidder
     * @param {AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuctionsApi
     */
    public selectHighestBidderAuctionsRoomsSelectHighestBidderPost(requestParameters: AuctionsApiSelectHighestBidderAuctionsRoomsSelectHighestBidderPostRequest, options?: RawAxiosRequestConfig) {
        return AuctionsApiFp(this.configuration).selectHighestBidderAuctionsRoomsSelectHighestBidderPost(requestParameters.selectHighestBidderInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Close Round
         * @param {string} roomId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost: async (roomId: string, roundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost', 'roomId', roomId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost', 'roundId', roundId)
            const localVarPath = `/extensions/rooms/{room_id}/round/{round_id}/close/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Extension Commitment
         * @param {CreateExtensionCommitmentInput} createExtensionCommitmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExtensionCommitmentExtensionsRoomsCommitmentsPost: async (createExtensionCommitmentInput: CreateExtensionCommitmentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createExtensionCommitmentInput' is not null or undefined
            assertParamExists('createExtensionCommitmentExtensionsRoomsCommitmentsPost', 'createExtensionCommitmentInput', createExtensionCommitmentInput)
            const localVarPath = `/extensions/rooms/commitments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExtensionCommitmentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create New Round
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewRoundExtensionsRoomsRoomIdRoundPost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createNewRoundExtensionsRoomsRoomIdRoundPost', 'roomId', roomId)
            const localVarPath = `/extensions/rooms/{room_id}/round/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Commitment Total
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet', 'roomId', roomId)
            const localVarPath = `/extensions/rooms/{room_id}/commitments/total/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Extension Price
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionPriceExtensionsRoomsRoomIdPriceGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getExtensionPriceExtensionsRoomsRoomIdPriceGet', 'roomId', roomId)
            const localVarPath = `/extensions/rooms/{room_id}/price/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Extensions Cache
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionsCacheExtensionsRoomsRoomIdCacheGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getExtensionsCacheExtensionsRoomsRoomIdCacheGet', 'roomId', roomId)
            const localVarPath = `/extensions/rooms/{room_id}/cache/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Round Id
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoundIdExtensionsRoomsRoomIdRoundIdGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoundIdExtensionsRoomsRoomIdRoundIdGet', 'roomId', roomId)
            const localVarPath = `/extensions/rooms/{room_id}/round-id/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Close Round
         * @param {string} roomId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost(roomId: string, roundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost(roomId, roundId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Extension Commitment
         * @param {CreateExtensionCommitmentInput} createExtensionCommitmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExtensionCommitmentExtensionsRoomsCommitmentsPost(createExtensionCommitmentInput: CreateExtensionCommitmentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExtensionCommitmentExtensionsRoomsCommitmentsPost(createExtensionCommitmentInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.createExtensionCommitmentExtensionsRoomsCommitmentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create New Round
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewRoundExtensionsRoomsRoomIdRoundPost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewRoundExtensionsRoomsRoomIdRoundPost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.createNewRoundExtensionsRoomsRoomIdRoundPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Commitment Total
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCommitmentTotalOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Extension Price
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensionPriceExtensionsRoomsRoomIdPriceGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExtensionPriceOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensionPriceExtensionsRoomsRoomIdPriceGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.getExtensionPriceExtensionsRoomsRoomIdPriceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Extensions Cache
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensionsCacheExtensionsRoomsRoomIdCacheGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExtensionCacheOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensionsCacheExtensionsRoomsRoomIdCacheGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.getExtensionsCacheExtensionsRoomsRoomIdCacheGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Round Id
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoundIdExtensionsRoomsRoomIdRoundIdGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArcadeRoomExtensionsOutputsGetRoundID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoundIdExtensionsRoomsRoomIdRoundIdGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.getRoundIdExtensionsRoomsRoomIdRoundIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Close Round
         * @param {ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost(requestParameters: ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost(requestParameters.roomId, requestParameters.roundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Extension Commitment
         * @param {ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExtensionCommitmentExtensionsRoomsCommitmentsPost(requestParameters: ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createExtensionCommitmentExtensionsRoomsCommitmentsPost(requestParameters.createExtensionCommitmentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create New Round
         * @param {ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewRoundExtensionsRoomsRoomIdRoundPost(requestParameters: ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createNewRoundExtensionsRoomsRoomIdRoundPost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Commitment Total
         * @param {ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet(requestParameters: ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCommitmentTotalOutput> {
            return localVarFp.getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Extension Price
         * @param {ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionPriceExtensionsRoomsRoomIdPriceGet(requestParameters: ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetExtensionPriceOutput> {
            return localVarFp.getExtensionPriceExtensionsRoomsRoomIdPriceGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Extensions Cache
         * @param {ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionsCacheExtensionsRoomsRoomIdCacheGet(requestParameters: ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetExtensionCacheOutput> {
            return localVarFp.getExtensionsCacheExtensionsRoomsRoomIdCacheGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Round Id
         * @param {ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoundIdExtensionsRoomsRoomIdRoundIdGet(requestParameters: ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ArcadeRoomExtensionsOutputsGetRoundID> {
            return localVarFp.getRoundIdExtensionsRoomsRoomIdRoundIdGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePostRequest
 */
export interface ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePost
     */
    readonly roomId: string

    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePost
     */
    readonly roundId: string
}

/**
 * Request parameters for createExtensionCommitmentExtensionsRoomsCommitmentsPost operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPostRequest
 */
export interface ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPostRequest {
    /**
     * 
     * @type {CreateExtensionCommitmentInput}
     * @memberof ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPost
     */
    readonly createExtensionCommitmentInput: CreateExtensionCommitmentInput
}

/**
 * Request parameters for createNewRoundExtensionsRoomsRoomIdRoundPost operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPostRequest
 */
export interface ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPost
     */
    readonly roomId: string
}

/**
 * Request parameters for getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGetRequest
 */
export interface ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getExtensionPriceExtensionsRoomsRoomIdPriceGet operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGetRequest
 */
export interface ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getExtensionsCacheExtensionsRoomsRoomIdCacheGet operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGetRequest
 */
export interface ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getRoundIdExtensionsRoomsRoomIdRoundIdGet operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGetRequest
 */
export interface ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGet
     */
    readonly roomId: string
}

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * 
     * @summary Close Round
     * @param {ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost(requestParameters: ExtensionsApiCloseRoundExtensionsRoomsRoomIdRoundRoundIdClosePostRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).closeRoundExtensionsRoomsRoomIdRoundRoundIdClosePost(requestParameters.roomId, requestParameters.roundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Extension Commitment
     * @param {ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public createExtensionCommitmentExtensionsRoomsCommitmentsPost(requestParameters: ExtensionsApiCreateExtensionCommitmentExtensionsRoomsCommitmentsPostRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).createExtensionCommitmentExtensionsRoomsCommitmentsPost(requestParameters.createExtensionCommitmentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create New Round
     * @param {ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public createNewRoundExtensionsRoomsRoomIdRoundPost(requestParameters: ExtensionsApiCreateNewRoundExtensionsRoomsRoomIdRoundPostRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).createNewRoundExtensionsRoomsRoomIdRoundPost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Commitment Total
     * @param {ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet(requestParameters: ExtensionsApiGetCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGetRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getCommitmentTotalExtensionsRoomsRoomIdCommitmentsTotalGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Extension Price
     * @param {ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getExtensionPriceExtensionsRoomsRoomIdPriceGet(requestParameters: ExtensionsApiGetExtensionPriceExtensionsRoomsRoomIdPriceGetRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getExtensionPriceExtensionsRoomsRoomIdPriceGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Extensions Cache
     * @param {ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getExtensionsCacheExtensionsRoomsRoomIdCacheGet(requestParameters: ExtensionsApiGetExtensionsCacheExtensionsRoomsRoomIdCacheGetRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getExtensionsCacheExtensionsRoomsRoomIdCacheGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Round Id
     * @param {ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getRoundIdExtensionsRoomsRoomIdRoundIdGet(requestParameters: ExtensionsApiGetRoundIdExtensionsRoomsRoomIdRoundIdGetRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getRoundIdExtensionsRoomsRoomIdRoundIdGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Apple Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete', 'transactionId', transactionId)
            const localVarPath = `/payments/apple/transactions/{transaction_id}/`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify Apple Transaction
         * @param {VerifyAppleTransactionInput} verifyAppleTransactionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAppleTransactionPaymentsAppleVerifyPost: async (verifyAppleTransactionInput: VerifyAppleTransactionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyAppleTransactionInput' is not null or undefined
            assertParamExists('verifyAppleTransactionPaymentsAppleVerifyPost', 'verifyAppleTransactionInput', verifyAppleTransactionInput)
            const localVarPath = `/payments/apple/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyAppleTransactionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify Google Transaction
         * @param {VerifyGoogleTransactionInput} verifyGoogleTransactionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyGoogleTransactionPaymentsGoogleVerifyPost: async (verifyGoogleTransactionInput: VerifyGoogleTransactionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyGoogleTransactionInput' is not null or undefined
            assertParamExists('verifyGoogleTransactionPaymentsGoogleVerifyPost', 'verifyGoogleTransactionInput', verifyGoogleTransactionInput)
            const localVarPath = `/payments/google/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyGoogleTransactionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Apple Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete(transactionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentsApi.deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Verify Apple Transaction
         * @param {VerifyAppleTransactionInput} verifyAppleTransactionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAppleTransactionPaymentsAppleVerifyPost(verifyAppleTransactionInput: VerifyAppleTransactionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyAppleTransactionPaymentsAppleVerifyPost(verifyAppleTransactionInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentsApi.verifyAppleTransactionPaymentsAppleVerifyPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Verify Google Transaction
         * @param {VerifyGoogleTransactionInput} verifyGoogleTransactionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyGoogleTransactionPaymentsGoogleVerifyPost(verifyGoogleTransactionInput: VerifyGoogleTransactionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyGoogleTransactionPaymentsGoogleVerifyPost(verifyGoogleTransactionInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PaymentsApi.verifyGoogleTransactionPaymentsGoogleVerifyPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Apple Transaction
         * @param {PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete(requestParameters: PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify Apple Transaction
         * @param {PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAppleTransactionPaymentsAppleVerifyPost(requestParameters: PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.verifyAppleTransactionPaymentsAppleVerifyPost(requestParameters.verifyAppleTransactionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify Google Transaction
         * @param {PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyGoogleTransactionPaymentsGoogleVerifyPost(requestParameters: PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.verifyGoogleTransactionPaymentsGoogleVerifyPost(requestParameters.verifyGoogleTransactionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete operation in PaymentsApi.
 * @export
 * @interface PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDeleteRequest
 */
export interface PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete
     */
    readonly transactionId: string
}

/**
 * Request parameters for verifyAppleTransactionPaymentsAppleVerifyPost operation in PaymentsApi.
 * @export
 * @interface PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPostRequest
 */
export interface PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPostRequest {
    /**
     * 
     * @type {VerifyAppleTransactionInput}
     * @memberof PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPost
     */
    readonly verifyAppleTransactionInput: VerifyAppleTransactionInput
}

/**
 * Request parameters for verifyGoogleTransactionPaymentsGoogleVerifyPost operation in PaymentsApi.
 * @export
 * @interface PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPostRequest
 */
export interface PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPostRequest {
    /**
     * 
     * @type {VerifyGoogleTransactionInput}
     * @memberof PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPost
     */
    readonly verifyGoogleTransactionInput: VerifyGoogleTransactionInput
}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Apple Transaction
     * @param {PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete(requestParameters: PaymentsApiDeleteAppleTransactionPaymentsAppleTransactionsTransactionIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).deleteAppleTransactionPaymentsAppleTransactionsTransactionIdDelete(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify Apple Transaction
     * @param {PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public verifyAppleTransactionPaymentsAppleVerifyPost(requestParameters: PaymentsApiVerifyAppleTransactionPaymentsAppleVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).verifyAppleTransactionPaymentsAppleVerifyPost(requestParameters.verifyAppleTransactionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify Google Transaction
     * @param {PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public verifyGoogleTransactionPaymentsGoogleVerifyPost(requestParameters: PaymentsApiVerifyGoogleTransactionPaymentsGoogleVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).verifyGoogleTransactionPaymentsGoogleVerifyPost(requestParameters.verifyGoogleTransactionInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Token Ledger
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenLedgerTokensLedgersUsersUserIdPost: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createTokenLedgerTokensLedgersUsersUserIdPost', 'userId', userId)
            const localVarPath = `/tokens/ledgers/users/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Token Transaction
         * @param {CreateTokenTransactionInput} createTokenTransactionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenTransactionTokensTransactionsUsersPost: async (createTokenTransactionInput: CreateTokenTransactionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTokenTransactionInput' is not null or undefined
            assertParamExists('createTokenTransactionTokensTransactionsUsersPost', 'createTokenTransactionInput', createTokenTransactionInput)
            const localVarPath = `/tokens/transactions/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTokenTransactionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token Count
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenCountTokensLedgersUsersUserIdCountGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTokenCountTokensLedgersUsersUserIdCountGet', 'userId', userId)
            const localVarPath = `/tokens/ledgers/users/{user_id}/count/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Escrow Token Count
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet', 'userId', userId)
            const localVarPath = `/tokens/ledgers/users/{user_id}/escrow/count/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Token Ledger
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenLedgerTokensLedgersUsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserTokenLedgerTokensLedgersUsersUserIdGet', 'userId', userId)
            const localVarPath = `/tokens/ledgers/users/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Token Transactions
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenTransactionsTokensTransactionsUsersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserTokenTransactionsTokensTransactionsUsersUserIdGet', 'userId', userId)
            const localVarPath = `/tokens/transactions/users/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Token Ledger
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTokenLedgerTokensLedgersUsersUserIdPost(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenLedger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTokenLedgerTokensLedgersUsersUserIdPost(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokensApi.createTokenLedgerTokensLedgersUsersUserIdPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Token Transaction
         * @param {CreateTokenTransactionInput} createTokenTransactionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTokenTransactionTokensTransactionsUsersPost(createTokenTransactionInput: CreateTokenTransactionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTokenTransactionTokensTransactionsUsersPost(createTokenTransactionInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokensApi.createTokenTransactionTokensTransactionsUsersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Token Count
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenCountTokensLedgersUsersUserIdCountGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCountOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenCountTokensLedgersUsersUserIdCountGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokensApi.getTokenCountTokensLedgersUsersUserIdCountGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Escrow Token Count
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCountOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokensApi.getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Token Ledger
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenLedgerTokensLedgersUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenLedger>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenLedgerTokensLedgersUsersUserIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokensApi.getUserTokenLedgerTokensLedgersUsersUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Token Transactions
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTokenTransactionsTokensTransactionsUsersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTokenTransactionsTokensTransactionsUsersUserIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokensApi.getUserTokenTransactionsTokensTransactionsUsersUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Token Ledger
         * @param {TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenLedgerTokensLedgersUsersUserIdPost(requestParameters: TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenLedger> {
            return localVarFp.createTokenLedgerTokensLedgersUsersUserIdPost(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Token Transaction
         * @param {TokensApiCreateTokenTransactionTokensTransactionsUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenTransactionTokensTransactionsUsersPost(requestParameters: TokensApiCreateTokenTransactionTokensTransactionsUsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenTransaction> {
            return localVarFp.createTokenTransactionTokensTransactionsUsersPost(requestParameters.createTokenTransactionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token Count
         * @param {TokensApiGetTokenCountTokensLedgersUsersUserIdCountGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenCountTokensLedgersUsersUserIdCountGet(requestParameters: TokensApiGetTokenCountTokensLedgersUsersUserIdCountGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenCountOutput> {
            return localVarFp.getTokenCountTokensLedgersUsersUserIdCountGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Escrow Token Count
         * @param {TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet(requestParameters: TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenCountOutput> {
            return localVarFp.getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Token Ledger
         * @param {TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenLedgerTokensLedgersUsersUserIdGet(requestParameters: TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenLedger> {
            return localVarFp.getUserTokenLedgerTokensLedgersUsersUserIdGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Token Transactions
         * @param {TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTokenTransactionsTokensTransactionsUsersUserIdGet(requestParameters: TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenTransaction>> {
            return localVarFp.getUserTokenTransactionsTokensTransactionsUsersUserIdGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTokenLedgerTokensLedgersUsersUserIdPost operation in TokensApi.
 * @export
 * @interface TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPostRequest
 */
export interface TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPost
     */
    readonly userId: string
}

/**
 * Request parameters for createTokenTransactionTokensTransactionsUsersPost operation in TokensApi.
 * @export
 * @interface TokensApiCreateTokenTransactionTokensTransactionsUsersPostRequest
 */
export interface TokensApiCreateTokenTransactionTokensTransactionsUsersPostRequest {
    /**
     * 
     * @type {CreateTokenTransactionInput}
     * @memberof TokensApiCreateTokenTransactionTokensTransactionsUsersPost
     */
    readonly createTokenTransactionInput: CreateTokenTransactionInput
}

/**
 * Request parameters for getTokenCountTokensLedgersUsersUserIdCountGet operation in TokensApi.
 * @export
 * @interface TokensApiGetTokenCountTokensLedgersUsersUserIdCountGetRequest
 */
export interface TokensApiGetTokenCountTokensLedgersUsersUserIdCountGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TokensApiGetTokenCountTokensLedgersUsersUserIdCountGet
     */
    readonly userId: string
}

/**
 * Request parameters for getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet operation in TokensApi.
 * @export
 * @interface TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGetRequest
 */
export interface TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet
     */
    readonly userId: string
}

/**
 * Request parameters for getUserTokenLedgerTokensLedgersUsersUserIdGet operation in TokensApi.
 * @export
 * @interface TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGetRequest
 */
export interface TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for getUserTokenTransactionsTokensTransactionsUsersUserIdGet operation in TokensApi.
 * @export
 * @interface TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGetRequest
 */
export interface TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGet
     */
    readonly userId: string
}

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * 
     * @summary Create Token Ledger
     * @param {TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createTokenLedgerTokensLedgersUsersUserIdPost(requestParameters: TokensApiCreateTokenLedgerTokensLedgersUsersUserIdPostRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).createTokenLedgerTokensLedgersUsersUserIdPost(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Token Transaction
     * @param {TokensApiCreateTokenTransactionTokensTransactionsUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createTokenTransactionTokensTransactionsUsersPost(requestParameters: TokensApiCreateTokenTransactionTokensTransactionsUsersPostRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).createTokenTransactionTokensTransactionsUsersPost(requestParameters.createTokenTransactionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token Count
     * @param {TokensApiGetTokenCountTokensLedgersUsersUserIdCountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getTokenCountTokensLedgersUsersUserIdCountGet(requestParameters: TokensApiGetTokenCountTokensLedgersUsersUserIdCountGetRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getTokenCountTokensLedgersUsersUserIdCountGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Escrow Token Count
     * @param {TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet(requestParameters: TokensApiGetUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGetRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getUserEscrowTokenCountTokensLedgersUsersUserIdEscrowCountGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Token Ledger
     * @param {TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getUserTokenLedgerTokensLedgersUsersUserIdGet(requestParameters: TokensApiGetUserTokenLedgerTokensLedgersUsersUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getUserTokenLedgerTokensLedgersUsersUserIdGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Token Transactions
     * @param {TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getUserTokenTransactionsTokensTransactionsUsersUserIdGet(requestParameters: TokensApiGetUserTokenTransactionsTokensTransactionsUsersUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getUserTokenTransactionsTokensTransactionsUsersUserIdGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}



