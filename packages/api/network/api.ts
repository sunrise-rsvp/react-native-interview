/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptIntroInput
 */
export interface AcceptIntroInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof AcceptIntroInput
     */
    'id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof AcceptIntroInput
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface AcceptorIntroductionState
 */
export interface AcceptorIntroductionState {
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'AWAITING_INTRODUCER'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'AWAITING_REQUESTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'DRAFT'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'DENIED'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'DENIED_BY_REQUESTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'DENIED_BY_INTRODUCER'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'ACCEPTED'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptorIntroductionState
     */
    'AWAITING_ACCEPTOR'?: string;
}
/**
 * 
 * @export
 * @interface ConnectedWithCreateInput
 */
export interface ConnectedWithCreateInput {
    /**
     * 
     * @type {number}
     * @memberof ConnectedWithCreateInput
     */
    'minutes': number;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ConnectedWithCreateInput
     */
    'event_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ConnectedWithCreateInput
     */
    'user_1_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ConnectedWithCreateInput
     */
    'user_2_id': string;
}
/**
 * 
 * @export
 * @interface ConnectedWithInput
 */
export interface ConnectedWithInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ConnectedWithInput
     */
    'user_1_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof ConnectedWithInput
     */
    'user_2_id': string;
}
/**
 * 
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {CreatedDate}
     * @memberof Connection
     */
    'created_date'?: CreatedDate;
    /**
     * 
     * @type {ModifiedDate}
     * @memberof Connection
     */
    'modified_date'?: ModifiedDate;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Connection
     */
    'user_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Connection
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Connection
     */
    'minutes': number;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Connection
     */
    'event_id': string;
}
/**
 * 
 * @export
 * @interface CreatedDate
 */
export interface CreatedDate {
}
/**
 * 
 * @export
 * @interface DenyIntroInput
 */
export interface DenyIntroInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof DenyIntroInput
     */
    'id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof DenyIntroInput
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface FollowsInput
 */
export interface FollowsInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof FollowsInput
     */
    'follower_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof FollowsInput
     */
    'followed_id': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface IntroducedTo
 */
export interface IntroducedTo {
    /**
     * 
     * @type {boolean}
     * @memberof IntroducedTo
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {CreatedDate}
     * @memberof IntroducedTo
     */
    'created_date'?: CreatedDate;
    /**
     * 
     * @type {ModifiedDate}
     * @memberof IntroducedTo
     */
    'modified_date'?: ModifiedDate;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducedTo
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducedTo
     */
    'introducer_id': string;
    /**
     * 
     * @type {IntroductionReadStatus}
     * @memberof IntroducedTo
     */
    'read_status': IntroductionReadStatus;
    /**
     * 
     * @type {State}
     * @memberof IntroducedTo
     */
    'state': State;
    /**
     * 
     * @type {string}
     * @memberof IntroducedTo
     */
    'introducer_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntroducedTo
     */
    'intro_video_url'?: string;
    /**
     * 
     * @type {IntroductionRole}
     * @memberof IntroducedTo
     */
    'intro_role': IntroductionRole;
}


/**
 * 
 * @export
 * @interface IntroducedToInput
 */
export interface IntroducedToInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducedToInput
     */
    'introduced_person_1_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducedToInput
     */
    'introduced_person_2_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducedToInput
     */
    'introducer_id': string;
    /**
     * 
     * @type {string}
     * @memberof IntroducedToInput
     */
    'introducer_message': string;
    /**
     * 
     * @type {IntroducedToInputState}
     * @memberof IntroducedToInput
     */
    'state'?: IntroducedToInputState;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const IntroducedToInputState = {
    Pending: 'pending',
    Draft: 'draft'
} as const;

export type IntroducedToInputState = typeof IntroducedToInputState[keyof typeof IntroducedToInputState];


/**
 * 
 * @export
 * @interface IntroducerAcceptIntroInput
 */
export interface IntroducerAcceptIntroInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducerAcceptIntroInput
     */
    'introduced_user_1_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducerAcceptIntroInput
     */
    'introduced_user_2_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroducerAcceptIntroInput
     */
    'introducer_id': string;
    /**
     * 
     * @type {string}
     * @memberof IntroducerAcceptIntroInput
     */
    'introducer_message': string;
}
/**
 * 
 * @export
 * @interface Introduction
 */
export interface Introduction {
    /**
     * 
     * @type {Array<IntroductionHalf>}
     * @memberof Introduction
     */
    'introduction': Array<IntroductionHalf>;
}
/**
 * 
 * @export
 * @interface IntroductionHalf
 */
export interface IntroductionHalf {
    /**
     * 
     * @type {Person}
     * @memberof IntroductionHalf
     */
    'person': Person;
    /**
     * 
     * @type {IntroducedTo}
     * @memberof IntroductionHalf
     */
    'introduced_to': IntroducedTo;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const IntroductionReadStatus = {
    Pending: 'pending',
    Sent: 'sent',
    Seen: 'seen',
    Viewed: 'viewed'
} as const;

export type IntroductionReadStatus = typeof IntroductionReadStatus[keyof typeof IntroductionReadStatus];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const IntroductionRole = {
    Requestor: 'requestor',
    Acceptor: 'acceptor'
} as const;

export type IntroductionRole = typeof IntroductionRole[keyof typeof IntroductionRole];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const IntroductionsByMeStates = {
    Drafts: 'drafts',
    Pending: 'pending',
    Accepted: 'accepted',
    Denied: 'denied'
} as const;

export type IntroductionsByMeStates = typeof IntroductionsByMeStates[keyof typeof IntroductionsByMeStates];


/**
 * 
 * @export
 * @interface IsConnectedWithOutput
 */
export interface IsConnectedWithOutput {
    /**
     * 
     * @type {boolean}
     * @memberof IsConnectedWithOutput
     */
    'is_connected': boolean;
}
/**
 * 
 * @export
 * @interface IsIntroducedInput
 */
export interface IsIntroducedInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IsIntroducedInput
     */
    'user_1_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IsIntroducedInput
     */
    'user_2_id': string;
}
/**
 * 
 * @export
 * @interface IsIntroducedOutput
 */
export interface IsIntroducedOutput {
    /**
     * 
     * @type {boolean}
     * @memberof IsIntroducedOutput
     */
    'is_introduced': boolean;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface ModifiedDate
 */
export interface ModifiedDate {
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const MyIntroductionsStates = {
    Pending: 'pending',
    Accepted: 'accepted',
    Denied: 'denied'
} as const;

export type MyIntroductionsStates = typeof MyIntroductionsStates[keyof typeof MyIntroductionsStates];


/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {CreatedDate}
     * @memberof Person
     */
    'created_date'?: CreatedDate;
    /**
     * 
     * @type {ModifiedDate}
     * @memberof Person
     */
    'modified_date'?: ModifiedDate;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Person
     */
    'user_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface PersonInput
 */
export interface PersonInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PersonInput
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface RelationshipStats
 */
export interface RelationshipStats {
    /**
     * 
     * @type {number}
     * @memberof RelationshipStats
     */
    'connection_count': number;
    /**
     * 
     * @type {number}
     * @memberof RelationshipStats
     */
    'follower_count': number;
    /**
     * 
     * @type {number}
     * @memberof RelationshipStats
     */
    'following_count': number;
}
/**
 * 
 * @export
 * @interface RequestorIntroductionState
 */
export interface RequestorIntroductionState {
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'DRAFT'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'DENIED'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'DENIED_BY_ACCEPTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'DENIED_BY_INTRODUCER'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'ACCEPTED'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'AWAITING_VIDEO'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'VIDEO_COMPLETED'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestorIntroductionState
     */
    'SENT_TO_ACCEPTOR'?: string;
}
/**
 * 
 * @export
 * @interface State
 */
export interface State {
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'DRAFT'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'DENIED'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'DENIED_BY_ACCEPTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'DENIED_BY_INTRODUCER'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'ACCEPTED'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'AWAITING_VIDEO'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'VIDEO_COMPLETED'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'SENT_TO_ACCEPTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'AWAITING_INTRODUCER'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'AWAITING_REQUESTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'DENIED_BY_REQUESTOR'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'AWAITING_ACCEPTOR'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectedWithCreateInput} connectedWithCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionConnectionsPost: async (connectedWithCreateInput: ConnectedWithCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectedWithCreateInput' is not null or undefined
            assertParamExists('createConnectionConnectionsPost', 'connectedWithCreateInput', connectedWithCreateInput)
            const localVarPath = `/connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectedWithCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connection Path
         * @param {ConnectedWithInput} connectedWithInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionPathConnectionsConnectionPathPost: async (connectedWithInput: ConnectedWithInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectedWithInput' is not null or undefined
            assertParamExists('getConnectionPathConnectionsConnectionPathPost', 'connectedWithInput', connectedWithInput)
            const localVarPath = `/connections/connection-path/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectedWithInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connections
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsConnectionsUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getConnectionsConnectionsUserIdGet', 'userId', userId)
            const localVarPath = `/connections/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Connections For Event
         * @param {string} userId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsForEventConnectionsUserIdEventEventIdGet: async (userId: string, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getConnectionsForEventConnectionsUserIdEventEventIdGet', 'userId', userId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getConnectionsForEventConnectionsUserIdEventEventIdGet', 'eventId', eventId)
            const localVarPath = `/connections/{user_id}/event/{event_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Connected With
         * @param {string} user1Id 
         * @param {string} user2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isConnectedWithConnectionsIsConnectedGet: async (user1Id: string, user2Id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user1Id' is not null or undefined
            assertParamExists('isConnectedWithConnectionsIsConnectedGet', 'user1Id', user1Id)
            // verify required parameter 'user2Id' is not null or undefined
            assertParamExists('isConnectedWithConnectionsIsConnectedGet', 'user2Id', user2Id)
            const localVarPath = `/connections/is-connected/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (user1Id !== undefined) {
                localVarQueryParameter['user1_id'] = user1Id;
            }

            if (user2Id !== undefined) {
                localVarQueryParameter['user2_id'] = user2Id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectedWithCreateInput} connectedWithCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectionConnectionsPost(connectedWithCreateInput: ConnectedWithCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectionConnectionsPost(connectedWithCreateInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionsApi.createConnectionConnectionsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Connection Path
         * @param {ConnectedWithInput} connectedWithInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionPathConnectionsConnectionPathPost(connectedWithInput: ConnectedWithInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionPathConnectionsConnectionPathPost(connectedWithInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionsApi.getConnectionPathConnectionsConnectionPathPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Connections
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionsConnectionsUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionsConnectionsUserIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionsApi.getConnectionsConnectionsUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Connections For Event
         * @param {string} userId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionsForEventConnectionsUserIdEventEventIdGet(userId: string, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionsForEventConnectionsUserIdEventEventIdGet(userId, eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionsApi.getConnectionsForEventConnectionsUserIdEventEventIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Is Connected With
         * @param {string} user1Id 
         * @param {string} user2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isConnectedWithConnectionsIsConnectedGet(user1Id: string, user2Id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsConnectedWithOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isConnectedWithConnectionsIsConnectedGet(user1Id, user2Id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ConnectionsApi.isConnectedWithConnectionsIsConnectedGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Connection
         * @param {ConnectionsApiCreateConnectionConnectionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectionConnectionsPost(requestParameters: ConnectionsApiCreateConnectionConnectionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.createConnectionConnectionsPost(requestParameters.connectedWithCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connection Path
         * @param {ConnectionsApiGetConnectionPathConnectionsConnectionPathPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionPathConnectionsConnectionPathPost(requestParameters: ConnectionsApiGetConnectionPathConnectionsConnectionPathPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.getConnectionPathConnectionsConnectionPathPost(requestParameters.connectedWithInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connections
         * @param {ConnectionsApiGetConnectionsConnectionsUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsConnectionsUserIdGet(requestParameters: ConnectionsApiGetConnectionsConnectionsUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.getConnectionsConnectionsUserIdGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Connections For Event
         * @param {ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionsForEventConnectionsUserIdEventEventIdGet(requestParameters: ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connection>> {
            return localVarFp.getConnectionsForEventConnectionsUserIdEventEventIdGet(requestParameters.userId, requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Connected With
         * @param {ConnectionsApiIsConnectedWithConnectionsIsConnectedGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isConnectedWithConnectionsIsConnectedGet(requestParameters: ConnectionsApiIsConnectedWithConnectionsIsConnectedGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<IsConnectedWithOutput> {
            return localVarFp.isConnectedWithConnectionsIsConnectedGet(requestParameters.user1Id, requestParameters.user2Id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConnectionConnectionsPost operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiCreateConnectionConnectionsPostRequest
 */
export interface ConnectionsApiCreateConnectionConnectionsPostRequest {
    /**
     * 
     * @type {ConnectedWithCreateInput}
     * @memberof ConnectionsApiCreateConnectionConnectionsPost
     */
    readonly connectedWithCreateInput: ConnectedWithCreateInput
}

/**
 * Request parameters for getConnectionPathConnectionsConnectionPathPost operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiGetConnectionPathConnectionsConnectionPathPostRequest
 */
export interface ConnectionsApiGetConnectionPathConnectionsConnectionPathPostRequest {
    /**
     * 
     * @type {ConnectedWithInput}
     * @memberof ConnectionsApiGetConnectionPathConnectionsConnectionPathPost
     */
    readonly connectedWithInput: ConnectedWithInput
}

/**
 * Request parameters for getConnectionsConnectionsUserIdGet operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiGetConnectionsConnectionsUserIdGetRequest
 */
export interface ConnectionsApiGetConnectionsConnectionsUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiGetConnectionsConnectionsUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for getConnectionsForEventConnectionsUserIdEventEventIdGet operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGetRequest
 */
export interface ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGet
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGet
     */
    readonly eventId: string
}

/**
 * Request parameters for isConnectedWithConnectionsIsConnectedGet operation in ConnectionsApi.
 * @export
 * @interface ConnectionsApiIsConnectedWithConnectionsIsConnectedGetRequest
 */
export interface ConnectionsApiIsConnectedWithConnectionsIsConnectedGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiIsConnectedWithConnectionsIsConnectedGet
     */
    readonly user1Id: string

    /**
     * 
     * @type {string}
     * @memberof ConnectionsApiIsConnectedWithConnectionsIsConnectedGet
     */
    readonly user2Id: string
}

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Create Connection
     * @param {ConnectionsApiCreateConnectionConnectionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public createConnectionConnectionsPost(requestParameters: ConnectionsApiCreateConnectionConnectionsPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).createConnectionConnectionsPost(requestParameters.connectedWithCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connection Path
     * @param {ConnectionsApiGetConnectionPathConnectionsConnectionPathPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getConnectionPathConnectionsConnectionPathPost(requestParameters: ConnectionsApiGetConnectionPathConnectionsConnectionPathPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnectionPathConnectionsConnectionPathPost(requestParameters.connectedWithInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connections
     * @param {ConnectionsApiGetConnectionsConnectionsUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getConnectionsConnectionsUserIdGet(requestParameters: ConnectionsApiGetConnectionsConnectionsUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnectionsConnectionsUserIdGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Connections For Event
     * @param {ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public getConnectionsForEventConnectionsUserIdEventEventIdGet(requestParameters: ConnectionsApiGetConnectionsForEventConnectionsUserIdEventEventIdGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnectionsForEventConnectionsUserIdEventEventIdGet(requestParameters.userId, requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Connected With
     * @param {ConnectionsApiIsConnectedWithConnectionsIsConnectedGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public isConnectedWithConnectionsIsConnectedGet(requestParameters: ConnectionsApiIsConnectedWithConnectionsIsConnectedGetRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).isConnectedWithConnectionsIsConnectedGet(requestParameters.user1Id, requestParameters.user2Id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FollowsApi - axios parameter creator
 * @export
 */
export const FollowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Follow User
         * @param {FollowsInput} followsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUserFollowsPost: async (followsInput: FollowsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followsInput' is not null or undefined
            assertParamExists('followUserFollowsPost', 'followsInput', followsInput)
            const localVarPath = `/follows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Followers
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersFollowsUserIdFollowersGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowersFollowsUserIdFollowersGet', 'userId', userId)
            const localVarPath = `/follows/{user_id}/followers/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Following
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingFollowsUserIdFollowingGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowingFollowsUserIdFollowingGet', 'userId', userId)
            const localVarPath = `/follows/{user_id}/following/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow User
         * @param {FollowsInput} followsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUserFollowsUnfollowPost: async (followsInput: FollowsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followsInput' is not null or undefined
            assertParamExists('unfollowUserFollowsUnfollowPost', 'followsInput', followsInput)
            const localVarPath = `/follows/unfollow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowsApi - functional programming interface
 * @export
 */
export const FollowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Follow User
         * @param {FollowsInput} followsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUserFollowsPost(followsInput: FollowsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUserFollowsPost(followsInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowsApi.followUserFollowsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Followers
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowersFollowsUserIdFollowersGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowersFollowsUserIdFollowersGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowsApi.getFollowersFollowsUserIdFollowersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Following
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowingFollowsUserIdFollowingGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowingFollowsUserIdFollowingGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowsApi.getFollowingFollowsUserIdFollowingGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Unfollow User
         * @param {FollowsInput} followsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUserFollowsUnfollowPost(followsInput: FollowsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUserFollowsUnfollowPost(followsInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FollowsApi.unfollowUserFollowsUnfollowPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FollowsApi - factory interface
 * @export
 */
export const FollowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowsApiFp(configuration)
    return {
        /**
         * 
         * @summary Follow User
         * @param {FollowsApiFollowUserFollowsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUserFollowsPost(requestParameters: FollowsApiFollowUserFollowsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Person> {
            return localVarFp.followUserFollowsPost(requestParameters.followsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Followers
         * @param {FollowsApiGetFollowersFollowsUserIdFollowersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersFollowsUserIdFollowersGet(requestParameters: FollowsApiGetFollowersFollowsUserIdFollowersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.getFollowersFollowsUserIdFollowersGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Following
         * @param {FollowsApiGetFollowingFollowsUserIdFollowingGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowingFollowsUserIdFollowingGet(requestParameters: FollowsApiGetFollowingFollowsUserIdFollowingGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.getFollowingFollowsUserIdFollowingGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfollow User
         * @param {FollowsApiUnfollowUserFollowsUnfollowPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUserFollowsUnfollowPost(requestParameters: FollowsApiUnfollowUserFollowsUnfollowPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Person> {
            return localVarFp.unfollowUserFollowsUnfollowPost(requestParameters.followsInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for followUserFollowsPost operation in FollowsApi.
 * @export
 * @interface FollowsApiFollowUserFollowsPostRequest
 */
export interface FollowsApiFollowUserFollowsPostRequest {
    /**
     * 
     * @type {FollowsInput}
     * @memberof FollowsApiFollowUserFollowsPost
     */
    readonly followsInput: FollowsInput
}

/**
 * Request parameters for getFollowersFollowsUserIdFollowersGet operation in FollowsApi.
 * @export
 * @interface FollowsApiGetFollowersFollowsUserIdFollowersGetRequest
 */
export interface FollowsApiGetFollowersFollowsUserIdFollowersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FollowsApiGetFollowersFollowsUserIdFollowersGet
     */
    readonly userId: string
}

/**
 * Request parameters for getFollowingFollowsUserIdFollowingGet operation in FollowsApi.
 * @export
 * @interface FollowsApiGetFollowingFollowsUserIdFollowingGetRequest
 */
export interface FollowsApiGetFollowingFollowsUserIdFollowingGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FollowsApiGetFollowingFollowsUserIdFollowingGet
     */
    readonly userId: string
}

/**
 * Request parameters for unfollowUserFollowsUnfollowPost operation in FollowsApi.
 * @export
 * @interface FollowsApiUnfollowUserFollowsUnfollowPostRequest
 */
export interface FollowsApiUnfollowUserFollowsUnfollowPostRequest {
    /**
     * 
     * @type {FollowsInput}
     * @memberof FollowsApiUnfollowUserFollowsUnfollowPost
     */
    readonly followsInput: FollowsInput
}

/**
 * FollowsApi - object-oriented interface
 * @export
 * @class FollowsApi
 * @extends {BaseAPI}
 */
export class FollowsApi extends BaseAPI {
    /**
     * 
     * @summary Follow User
     * @param {FollowsApiFollowUserFollowsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowsApi
     */
    public followUserFollowsPost(requestParameters: FollowsApiFollowUserFollowsPostRequest, options?: RawAxiosRequestConfig) {
        return FollowsApiFp(this.configuration).followUserFollowsPost(requestParameters.followsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Followers
     * @param {FollowsApiGetFollowersFollowsUserIdFollowersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowsApi
     */
    public getFollowersFollowsUserIdFollowersGet(requestParameters: FollowsApiGetFollowersFollowsUserIdFollowersGetRequest, options?: RawAxiosRequestConfig) {
        return FollowsApiFp(this.configuration).getFollowersFollowsUserIdFollowersGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Following
     * @param {FollowsApiGetFollowingFollowsUserIdFollowingGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowsApi
     */
    public getFollowingFollowsUserIdFollowingGet(requestParameters: FollowsApiGetFollowingFollowsUserIdFollowingGetRequest, options?: RawAxiosRequestConfig) {
        return FollowsApiFp(this.configuration).getFollowingFollowsUserIdFollowingGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfollow User
     * @param {FollowsApiUnfollowUserFollowsUnfollowPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowsApi
     */
    public unfollowUserFollowsUnfollowPost(requestParameters: FollowsApiUnfollowUserFollowsUnfollowPostRequest, options?: RawAxiosRequestConfig) {
        return FollowsApiFp(this.configuration).unfollowUserFollowsUnfollowPost(requestParameters.followsInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntroductionsApi - axios parameter creator
 * @export
 */
export const IntroductionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Acceptor Accept Introduction
         * @param {AcceptIntroInput} acceptIntroInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost: async (acceptIntroInput: AcceptIntroInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptIntroInput' is not null or undefined
            assertParamExists('acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost', 'acceptIntroInput', acceptIntroInput)
            const localVarPath = `/introductions/acceptor/accept/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptIntroInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Denied Introductions
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deniedIntroductionsIntroductionsUserIdDeniedGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deniedIntroductionsIntroductionsUserIdDeniedGet', 'userId', userId)
            const localVarPath = `/introductions/{user_id}/denied/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deny Introduction
         * @param {DenyIntroInput} denyIntroInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyIntroductionIntroductionsDenyPost: async (denyIntroInput: DenyIntroInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'denyIntroInput' is not null or undefined
            assertParamExists('denyIntroductionIntroductionsDenyPost', 'denyIntroInput', denyIntroInput)
            const localVarPath = `/introductions/deny/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(denyIntroInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Introduce Users
         * @param {IntroducedToInput} introducedToInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introduceUsersIntroductionsPost: async (introducedToInput: IntroducedToInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'introducedToInput' is not null or undefined
            assertParamExists('introduceUsersIntroductionsPost', 'introducedToInput', introducedToInput)
            const localVarPath = `/introductions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introducedToInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Introducer Accept Introduction
         * @param {IntroducerAcceptIntroInput} introducerAcceptIntroInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introducerAcceptIntroductionIntroductionsIntroducerAcceptPost: async (introducerAcceptIntroInput: IntroducerAcceptIntroInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'introducerAcceptIntroInput' is not null or undefined
            assertParamExists('introducerAcceptIntroductionIntroductionsIntroducerAcceptPost', 'introducerAcceptIntroInput', introducerAcceptIntroInput)
            const localVarPath = `/introductions/introducer/accept/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(introducerAcceptIntroInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Introduction Count
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introductionCountIntroductionsUserIdCountGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('introductionCountIntroductionsUserIdCountGet', 'userId', userId)
            const localVarPath = `/introductions/{user_id}/count/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Is Introduced
         * @param {IsIntroducedInput} isIntroducedInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isIntroducedIntroductionsIsIntroducedPost: async (isIntroducedInput: IsIntroducedInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isIntroducedInput' is not null or undefined
            assertParamExists('isIntroducedIntroductionsIsIntroducedPost', 'isIntroducedInput', isIntroducedInput)
            const localVarPath = `/introductions/is-introduced/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(isIntroducedInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Introductions Made By Me
         * @param {string} userId 
         * @param {IntroductionsByMeStates} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet: async (userId: string, state: IntroductionsByMeStates, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet', 'userId', userId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet', 'state', state)
            const localVarPath = `/introductions/{user_id}/made-by-me/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List My Introductions
         * @param {string} userId 
         * @param {MyIntroductionsStates} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyIntroductionsIntroductionsUserIdMyIntroductionsGet: async (userId: string, state: MyIntroductionsStates, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listMyIntroductionsIntroductionsUserIdMyIntroductionsGet', 'userId', userId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('listMyIntroductionsIntroductionsUserIdMyIntroductionsGet', 'state', state)
            const localVarPath = `/introductions/{user_id}/my-introductions/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Requestor Accept Introduction
         * @param {File} file 
         * @param {string} introId A unique identifier (UUID) in hexadecimal format
         * @param {string} userId A unique identifier (UUID) in hexadecimal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestorAcceptIntroductionIntroductionsRequestorAcceptPost: async (file: File, introId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('requestorAcceptIntroductionIntroductionsRequestorAcceptPost', 'file', file)
            // verify required parameter 'introId' is not null or undefined
            assertParamExists('requestorAcceptIntroductionIntroductionsRequestorAcceptPost', 'introId', introId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('requestorAcceptIntroductionIntroductionsRequestorAcceptPost', 'userId', userId)
            const localVarPath = `/introductions/requestor/accept/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (introId !== undefined) { 
                localVarFormParams.append('intro_id', introId as any);
            }
    
            if (userId !== undefined) { 
                localVarFormParams.append('user_id', userId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntroductionsApi - functional programming interface
 * @export
 */
export const IntroductionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntroductionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Acceptor Accept Introduction
         * @param {AcceptIntroInput} acceptIntroInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost(acceptIntroInput: AcceptIntroInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost(acceptIntroInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Denied Introductions
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deniedIntroductionsIntroductionsUserIdDeniedGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deniedIntroductionsIntroductionsUserIdDeniedGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.deniedIntroductionsIntroductionsUserIdDeniedGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Deny Introduction
         * @param {DenyIntroInput} denyIntroInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyIntroductionIntroductionsDenyPost(denyIntroInput: DenyIntroInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyIntroductionIntroductionsDenyPost(denyIntroInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.denyIntroductionIntroductionsDenyPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Introduce Users
         * @param {IntroducedToInput} introducedToInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async introduceUsersIntroductionsPost(introducedToInput: IntroducedToInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introduction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.introduceUsersIntroductionsPost(introducedToInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.introduceUsersIntroductionsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Introducer Accept Introduction
         * @param {IntroducerAcceptIntroInput} introducerAcceptIntroInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async introducerAcceptIntroductionIntroductionsIntroducerAcceptPost(introducerAcceptIntroInput: IntroducerAcceptIntroInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.introducerAcceptIntroductionIntroductionsIntroducerAcceptPost(introducerAcceptIntroInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.introducerAcceptIntroductionIntroductionsIntroducerAcceptPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Introduction Count
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async introductionCountIntroductionsUserIdCountGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.introductionCountIntroductionsUserIdCountGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.introductionCountIntroductionsUserIdCountGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Is Introduced
         * @param {IsIntroducedInput} isIntroducedInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isIntroducedIntroductionsIsIntroducedPost(isIntroducedInput: IsIntroducedInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsIntroducedOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isIntroducedIntroductionsIsIntroducedPost(isIntroducedInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.isIntroducedIntroductionsIsIntroducedPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Introductions Made By Me
         * @param {string} userId 
         * @param {IntroductionsByMeStates} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet(userId: string, state: IntroductionsByMeStates, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Introduction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet(userId, state, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List My Introductions
         * @param {string} userId 
         * @param {MyIntroductionsStates} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyIntroductionsIntroductionsUserIdMyIntroductionsGet(userId: string, state: MyIntroductionsStates, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Introduction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyIntroductionsIntroductionsUserIdMyIntroductionsGet(userId, state, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.listMyIntroductionsIntroductionsUserIdMyIntroductionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Requestor Accept Introduction
         * @param {File} file 
         * @param {string} introId A unique identifier (UUID) in hexadecimal format
         * @param {string} userId A unique identifier (UUID) in hexadecimal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestorAcceptIntroductionIntroductionsRequestorAcceptPost(file: File, introId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestorAcceptIntroductionIntroductionsRequestorAcceptPost(file, introId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['IntroductionsApi.requestorAcceptIntroductionIntroductionsRequestorAcceptPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * IntroductionsApi - factory interface
 * @export
 */
export const IntroductionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntroductionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Acceptor Accept Introduction
         * @param {IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost(requestParameters: IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost(requestParameters.acceptIntroInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Denied Introductions
         * @param {IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deniedIntroductionsIntroductionsUserIdDeniedGet(requestParameters: IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deniedIntroductionsIntroductionsUserIdDeniedGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deny Introduction
         * @param {IntroductionsApiDenyIntroductionIntroductionsDenyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyIntroductionIntroductionsDenyPost(requestParameters: IntroductionsApiDenyIntroductionIntroductionsDenyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.denyIntroductionIntroductionsDenyPost(requestParameters.denyIntroInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Introduce Users
         * @param {IntroductionsApiIntroduceUsersIntroductionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introduceUsersIntroductionsPost(requestParameters: IntroductionsApiIntroduceUsersIntroductionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Introduction> {
            return localVarFp.introduceUsersIntroductionsPost(requestParameters.introducedToInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Introducer Accept Introduction
         * @param {IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introducerAcceptIntroductionIntroductionsIntroducerAcceptPost(requestParameters: IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.introducerAcceptIntroductionIntroductionsIntroducerAcceptPost(requestParameters.introducerAcceptIntroInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Introduction Count
         * @param {IntroductionsApiIntroductionCountIntroductionsUserIdCountGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introductionCountIntroductionsUserIdCountGet(requestParameters: IntroductionsApiIntroductionCountIntroductionsUserIdCountGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.introductionCountIntroductionsUserIdCountGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Is Introduced
         * @param {IntroductionsApiIsIntroducedIntroductionsIsIntroducedPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isIntroducedIntroductionsIsIntroducedPost(requestParameters: IntroductionsApiIsIntroducedIntroductionsIsIntroducedPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<IsIntroducedOutput> {
            return localVarFp.isIntroducedIntroductionsIsIntroducedPost(requestParameters.isIntroducedInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Introductions Made By Me
         * @param {IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet(requestParameters: IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Introduction>> {
            return localVarFp.listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet(requestParameters.userId, requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List My Introductions
         * @param {IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyIntroductionsIntroductionsUserIdMyIntroductionsGet(requestParameters: IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Introduction>> {
            return localVarFp.listMyIntroductionsIntroductionsUserIdMyIntroductionsGet(requestParameters.userId, requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Requestor Accept Introduction
         * @param {IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestorAcceptIntroductionIntroductionsRequestorAcceptPost(requestParameters: IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.requestorAcceptIntroductionIntroductionsRequestorAcceptPost(requestParameters.file, requestParameters.introId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPostRequest
 */
export interface IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPostRequest {
    /**
     * 
     * @type {AcceptIntroInput}
     * @memberof IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPost
     */
    readonly acceptIntroInput: AcceptIntroInput
}

/**
 * Request parameters for deniedIntroductionsIntroductionsUserIdDeniedGet operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGetRequest
 */
export interface IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGetRequest {
    /**
     * 
     * @type {string}
     * @memberof IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGet
     */
    readonly userId: string
}

/**
 * Request parameters for denyIntroductionIntroductionsDenyPost operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiDenyIntroductionIntroductionsDenyPostRequest
 */
export interface IntroductionsApiDenyIntroductionIntroductionsDenyPostRequest {
    /**
     * 
     * @type {DenyIntroInput}
     * @memberof IntroductionsApiDenyIntroductionIntroductionsDenyPost
     */
    readonly denyIntroInput: DenyIntroInput
}

/**
 * Request parameters for introduceUsersIntroductionsPost operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiIntroduceUsersIntroductionsPostRequest
 */
export interface IntroductionsApiIntroduceUsersIntroductionsPostRequest {
    /**
     * 
     * @type {IntroducedToInput}
     * @memberof IntroductionsApiIntroduceUsersIntroductionsPost
     */
    readonly introducedToInput: IntroducedToInput
}

/**
 * Request parameters for introducerAcceptIntroductionIntroductionsIntroducerAcceptPost operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPostRequest
 */
export interface IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPostRequest {
    /**
     * 
     * @type {IntroducerAcceptIntroInput}
     * @memberof IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPost
     */
    readonly introducerAcceptIntroInput: IntroducerAcceptIntroInput
}

/**
 * Request parameters for introductionCountIntroductionsUserIdCountGet operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiIntroductionCountIntroductionsUserIdCountGetRequest
 */
export interface IntroductionsApiIntroductionCountIntroductionsUserIdCountGetRequest {
    /**
     * 
     * @type {string}
     * @memberof IntroductionsApiIntroductionCountIntroductionsUserIdCountGet
     */
    readonly userId: string
}

/**
 * Request parameters for isIntroducedIntroductionsIsIntroducedPost operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiIsIntroducedIntroductionsIsIntroducedPostRequest
 */
export interface IntroductionsApiIsIntroducedIntroductionsIsIntroducedPostRequest {
    /**
     * 
     * @type {IsIntroducedInput}
     * @memberof IntroductionsApiIsIntroducedIntroductionsIsIntroducedPost
     */
    readonly isIntroducedInput: IsIntroducedInput
}

/**
 * Request parameters for listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGetRequest
 */
export interface IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet
     */
    readonly userId: string

    /**
     * 
     * @type {IntroductionsByMeStates}
     * @memberof IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet
     */
    readonly state: IntroductionsByMeStates
}

/**
 * Request parameters for listMyIntroductionsIntroductionsUserIdMyIntroductionsGet operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGetRequest
 */
export interface IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGet
     */
    readonly userId: string

    /**
     * 
     * @type {MyIntroductionsStates}
     * @memberof IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGet
     */
    readonly state: MyIntroductionsStates
}

/**
 * Request parameters for requestorAcceptIntroductionIntroductionsRequestorAcceptPost operation in IntroductionsApi.
 * @export
 * @interface IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPostRequest
 */
export interface IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPostRequest {
    /**
     * 
     * @type {File}
     * @memberof IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPost
     */
    readonly file: File

    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPost
     */
    readonly introId: string

    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPost
     */
    readonly userId: string
}

/**
 * IntroductionsApi - object-oriented interface
 * @export
 * @class IntroductionsApi
 * @extends {BaseAPI}
 */
export class IntroductionsApi extends BaseAPI {
    /**
     * 
     * @summary Acceptor Accept Introduction
     * @param {IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost(requestParameters: IntroductionsApiAcceptorAcceptIntroductionIntroductionsAcceptorAcceptPostRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).acceptorAcceptIntroductionIntroductionsAcceptorAcceptPost(requestParameters.acceptIntroInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Denied Introductions
     * @param {IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public deniedIntroductionsIntroductionsUserIdDeniedGet(requestParameters: IntroductionsApiDeniedIntroductionsIntroductionsUserIdDeniedGetRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).deniedIntroductionsIntroductionsUserIdDeniedGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deny Introduction
     * @param {IntroductionsApiDenyIntroductionIntroductionsDenyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public denyIntroductionIntroductionsDenyPost(requestParameters: IntroductionsApiDenyIntroductionIntroductionsDenyPostRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).denyIntroductionIntroductionsDenyPost(requestParameters.denyIntroInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Introduce Users
     * @param {IntroductionsApiIntroduceUsersIntroductionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public introduceUsersIntroductionsPost(requestParameters: IntroductionsApiIntroduceUsersIntroductionsPostRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).introduceUsersIntroductionsPost(requestParameters.introducedToInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Introducer Accept Introduction
     * @param {IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public introducerAcceptIntroductionIntroductionsIntroducerAcceptPost(requestParameters: IntroductionsApiIntroducerAcceptIntroductionIntroductionsIntroducerAcceptPostRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).introducerAcceptIntroductionIntroductionsIntroducerAcceptPost(requestParameters.introducerAcceptIntroInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Introduction Count
     * @param {IntroductionsApiIntroductionCountIntroductionsUserIdCountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public introductionCountIntroductionsUserIdCountGet(requestParameters: IntroductionsApiIntroductionCountIntroductionsUserIdCountGetRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).introductionCountIntroductionsUserIdCountGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Is Introduced
     * @param {IntroductionsApiIsIntroducedIntroductionsIsIntroducedPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public isIntroducedIntroductionsIsIntroducedPost(requestParameters: IntroductionsApiIsIntroducedIntroductionsIsIntroducedPostRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).isIntroducedIntroductionsIsIntroducedPost(requestParameters.isIntroducedInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Introductions Made By Me
     * @param {IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet(requestParameters: IntroductionsApiListIntroductionsMadeByMeIntroductionsUserIdMadeByMeGetRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).listIntroductionsMadeByMeIntroductionsUserIdMadeByMeGet(requestParameters.userId, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List My Introductions
     * @param {IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public listMyIntroductionsIntroductionsUserIdMyIntroductionsGet(requestParameters: IntroductionsApiListMyIntroductionsIntroductionsUserIdMyIntroductionsGetRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).listMyIntroductionsIntroductionsUserIdMyIntroductionsGet(requestParameters.userId, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Requestor Accept Introduction
     * @param {IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntroductionsApi
     */
    public requestorAcceptIntroductionIntroductionsRequestorAcceptPost(requestParameters: IntroductionsApiRequestorAcceptIntroductionIntroductionsRequestorAcceptPostRequest, options?: RawAxiosRequestConfig) {
        return IntroductionsApiFp(this.configuration).requestorAcceptIntroductionIntroductionsRequestorAcceptPost(requestParameters.file, requestParameters.introId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleApi - axios parameter creator
 * @export
 */
export const PeopleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Person
         * @param {PersonInput} personInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonPeoplePost: async (personInput: PersonInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personInput' is not null or undefined
            assertParamExists('createPersonPeoplePost', 'personInput', personInput)
            const localVarPath = `/people/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Person By User Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonByUserIdPeopleUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPersonByUserIdPeopleUserIdGet', 'userId', userId)
            const localVarPath = `/people/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Relationship Stats
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatsPeopleUserIdRelationshipStatsGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getRelationshipStatsPeopleUserIdRelationshipStatsGet', 'userId', userId)
            const localVarPath = `/people/{user_id}/relationship/stats/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Second Degree Connections
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet', 'userId', userId)
            const localVarPath = `/people/{user_id}/second-degree-connections/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All People
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPeoplePeopleGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/people/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleApi - functional programming interface
 * @export
 */
export const PeopleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Person
         * @param {PersonInput} personInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonPeoplePost(personInput: PersonInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonPeoplePost(personInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PeopleApi.createPersonPeoplePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Person By User Id
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonByUserIdPeopleUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonByUserIdPeopleUserIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PeopleApi.getPersonByUserIdPeopleUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Relationship Stats
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationshipStatsPeopleUserIdRelationshipStatsGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationshipStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationshipStatsPeopleUserIdRelationshipStatsGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PeopleApi.getRelationshipStatsPeopleUserIdRelationshipStatsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Second Degree Connections
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PeopleApi.getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List All People
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllPeoplePeopleGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllPeoplePeopleGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PeopleApi.listAllPeoplePeopleGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PeopleApi - factory interface
 * @export
 */
export const PeopleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Person
         * @param {PeopleApiCreatePersonPeoplePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonPeoplePost(requestParameters: PeopleApiCreatePersonPeoplePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Person> {
            return localVarFp.createPersonPeoplePost(requestParameters.personInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Person By User Id
         * @param {PeopleApiGetPersonByUserIdPeopleUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonByUserIdPeopleUserIdGet(requestParameters: PeopleApiGetPersonByUserIdPeopleUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Person> {
            return localVarFp.getPersonByUserIdPeopleUserIdGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Relationship Stats
         * @param {PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationshipStatsPeopleUserIdRelationshipStatsGet(requestParameters: PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RelationshipStats> {
            return localVarFp.getRelationshipStatsPeopleUserIdRelationshipStatsGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Second Degree Connections
         * @param {PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet(requestParameters: PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All People
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPeoplePeopleGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Person>> {
            return localVarFp.listAllPeoplePeopleGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonPeoplePost operation in PeopleApi.
 * @export
 * @interface PeopleApiCreatePersonPeoplePostRequest
 */
export interface PeopleApiCreatePersonPeoplePostRequest {
    /**
     * 
     * @type {PersonInput}
     * @memberof PeopleApiCreatePersonPeoplePost
     */
    readonly personInput: PersonInput
}

/**
 * Request parameters for getPersonByUserIdPeopleUserIdGet operation in PeopleApi.
 * @export
 * @interface PeopleApiGetPersonByUserIdPeopleUserIdGetRequest
 */
export interface PeopleApiGetPersonByUserIdPeopleUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PeopleApiGetPersonByUserIdPeopleUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for getRelationshipStatsPeopleUserIdRelationshipStatsGet operation in PeopleApi.
 * @export
 * @interface PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGetRequest
 */
export interface PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGet
     */
    readonly userId: string
}

/**
 * Request parameters for getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet operation in PeopleApi.
 * @export
 * @interface PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGetRequest
 */
export interface PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet
     */
    readonly userId: string
}

/**
 * PeopleApi - object-oriented interface
 * @export
 * @class PeopleApi
 * @extends {BaseAPI}
 */
export class PeopleApi extends BaseAPI {
    /**
     * 
     * @summary Create Person
     * @param {PeopleApiCreatePersonPeoplePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public createPersonPeoplePost(requestParameters: PeopleApiCreatePersonPeoplePostRequest, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).createPersonPeoplePost(requestParameters.personInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Person By User Id
     * @param {PeopleApiGetPersonByUserIdPeopleUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public getPersonByUserIdPeopleUserIdGet(requestParameters: PeopleApiGetPersonByUserIdPeopleUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getPersonByUserIdPeopleUserIdGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Relationship Stats
     * @param {PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public getRelationshipStatsPeopleUserIdRelationshipStatsGet(requestParameters: PeopleApiGetRelationshipStatsPeopleUserIdRelationshipStatsGetRequest, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getRelationshipStatsPeopleUserIdRelationshipStatsGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Second Degree Connections
     * @param {PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet(requestParameters: PeopleApiGetSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGetRequest, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getSecondDegreeConnectionsPeopleUserIdSecondDegreeConnectionsGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All People
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeopleApi
     */
    public listAllPeoplePeopleGet(options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).listAllPeoplePeopleGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Health check endpoint for AWS load balancers and monitoring
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Health check endpoint for AWS load balancers and monitoring
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.healthCheckHealthGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Health check endpoint for AWS load balancers and monitoring
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Health check endpoint for AWS load balancers and monitoring
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



