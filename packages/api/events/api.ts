/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AttendeeCountOutput
 */
export interface AttendeeCountOutput {
    /**
     * 
     * @type {number}
     * @memberof AttendeeCountOutput
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface BulkExportTicketsInput
 */
export interface BulkExportTicketsInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkExportTicketsInput
     */
    'event_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface BulkGetEventsInput
 */
export interface BulkGetEventsInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkGetEventsInput
     */
    'event_ids': Array<string>;
    /**
     * 
     * @type {ExperienceType}
     * @memberof BulkGetEventsInput
     */
    'experience_type'?: ExperienceType;
}


/**
 * 
 * @export
 * @interface CheckoutInput
 */
export interface CheckoutInput {
    /**
     * 
     * @type {string}
     * @memberof CheckoutInput
     */
    'payment_method_id': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutInput
     */
    'discount_code'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CheckoutInput
     */
    'event_id': string;
    /**
     * 
     * @type {Array<TicketCheckoutData>}
     * @memberof CheckoutInput
     */
    'tickets': Array<TicketCheckoutData>;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CheckoutInput
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface CreateEventInput
 */
export interface CreateEventInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateEventInput
     */
    'user_id': string;
    /**
     * 
     * @type {ExperienceType}
     * @memberof CreateEventInput
     */
    'experience_type': ExperienceType;
    /**
     * 
     * @type {PermissionType}
     * @memberof CreateEventInput
     */
    'permission_type'?: PermissionType;
    /**
     * 
     * @type {string}
     * @memberof CreateEventInput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventInput
     */
    'description'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateEventInput
     */
    'organization_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateEventInput
     */
    'event_location_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventInput
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventInput
     */
    'scheduled_end_date'?: string;
}


/**
 * 
 * @export
 * @interface CreateEventLocationInput
 */
export interface CreateEventLocationInput {
    /**
     * 
     * @type {string}
     * @memberof CreateEventLocationInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventLocationInput
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventLocationInput
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventLocationInput
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventLocationInput
     */
    'postal_code'?: string;
}
/**
 * 
 * @export
 * @interface CreateEventTagsInput
 */
export interface CreateEventTagsInput {
    /**
     * 
     * @type {Array<EventTag>}
     * @memberof CreateEventTagsInput
     */
    'event_tags': Array<EventTag>;
}
/**
 * 
 * @export
 * @interface CreatePromoInput
 */
export interface CreatePromoInput {
    /**
     * 
     * @type {string}
     * @memberof CreatePromoInput
     */
    'name': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreatePromoInput
     */
    'event_id': string;
    /**
     * 
     * @type {DiscountType}
     * @memberof CreatePromoInput
     */
    'discount_type': DiscountType;
    /**
     * 
     * @type {number}
     * @memberof CreatePromoInput
     */
    'discount': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePromoInput
     */
    'is_stackable': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePromoInput
     */
    'ticket_type_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreatePromoInput
     */
    'discount_code': string;
}


/**
 * 
 * @export
 * @interface CreateRoomInput
 */
export interface CreateRoomInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateRoomInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateRoomInput
     */
    'event_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomInput
     */
    'start_date': string;
    /**
     * 
     * @type {ExperienceType}
     * @memberof CreateRoomInput
     */
    'experience_type': ExperienceType;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomInput
     */
    'topic_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomInput
     */
    'topic_description': string;
}


/**
 * 
 * @export
 * @interface CreateRoomOutput
 */
export interface CreateRoomOutput {
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'created_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'modified_date'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'slug': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'event_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'scheduled_end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'actual_end_date'?: string;
    /**
     * 
     * @type {ExperienceType}
     * @memberof CreateRoomOutput
     */
    'experience_type': ExperienceType;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'topic_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'topic_description': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomOutput
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoomOutput
     */
    'is_live'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoomOutput
     */
    'url': string;
}


/**
 * 
 * @export
 * @interface CreateTicketInput
 */
export interface CreateTicketInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateTicketInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateTicketInput
     */
    'event_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateTicketInput
     */
    'ticket_type_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTicketInput
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface CreateTicketTokenOutput
 */
export interface CreateTicketTokenOutput {
    /**
     * 
     * @type {string}
     * @memberof CreateTicketTokenOutput
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CreateTicketTypeInput
 */
export interface CreateTicketTypeInput {
    /**
     * 
     * @type {string}
     * @memberof CreateTicketTypeInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTicketTypeInput
     */
    'description': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateTicketTypeInput
     */
    'event_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTicketTypeInput
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface CreateVideoRoomInput
 */
export interface CreateVideoRoomInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateVideoRoomInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateVideoRoomInput
     */
    'event_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof CreateVideoRoomInput
     */
    'room_id': string;
    /**
     * 
     * @type {ExperienceType}
     * @memberof CreateVideoRoomInput
     */
    'experience_type': ExperienceType;
}


/**
 * Response model for event deletion endpoint
 * @export
 * @interface DeleteEventOutput
 */
export interface DeleteEventOutput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof DeleteEventOutput
     */
    'event_id': string;
}
/**
 * Response model for ticket deletion endpoint
 * @export
 * @interface DeleteTicketOutput
 */
export interface DeleteTicketOutput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof DeleteTicketOutput
     */
    'ticket_id': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const DiscountType = {
    Percent: 'percent',
    Fixed: 'fixed'
} as const;

export type DiscountType = typeof DiscountType[keyof typeof DiscountType];


/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Event
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Event
     */
    'organization_id': string;
    /**
     * 
     * @type {ExperienceType}
     * @memberof Event
     */
    'experience_type': ExperienceType;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'scheduled_end_date'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Event
     */
    'event_location_id'?: string;
    /**
     * 
     * @type {PermissionType}
     * @memberof Event
     */
    'permission_type': PermissionType;
}


/**
 * 
 * @export
 * @interface EventLocation
 */
export interface EventLocation {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof EventLocation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventLocation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EventLocation
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventLocation
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventLocation
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventLocation
     */
    'postal_code'?: string;
}
/**
 * 
 * @export
 * @interface EventTag
 */
export interface EventTag {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof EventTag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventTag
     */
    'name': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof EventTag
     */
    'event_id': string;
}
/**
 * Model for ticket count per event
 * @export
 * @interface EventTicketCount
 */
export interface EventTicketCount {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof EventTicketCount
     */
    'event_id': string;
    /**
     * 
     * @type {number}
     * @memberof EventTicketCount
     */
    'ticket_count': number;
}
/**
 * Response model for getting ticket counts across multiple events
 * @export
 * @interface EventTicketCountsResponse
 */
export interface EventTicketCountsResponse {
    /**
     * 
     * @type {Array<EventTicketCount>}
     * @memberof EventTicketCountsResponse
     */
    'events': Array<EventTicketCount>;
    /**
     * 
     * @type {number}
     * @memberof EventTicketCountsResponse
     */
    'total_events': number;
    /**
     * 
     * @type {number}
     * @memberof EventTicketCountsResponse
     */
    'total_tickets': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ExperienceType = {
    Sunrise: 'SUNRISE',
    PrivateRoom: 'PRIVATE_ROOM',
    Topic: 'TOPIC',
    InPerson: 'IN_PERSON',
    Custom: 'CUSTOM'
} as const;

export type ExperienceType = typeof ExperienceType[keyof typeof ExperienceType];


/**
 * 
 * @export
 * @interface GetTicketOutput
 */
export interface GetTicketOutput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof GetTicketOutput
     */
    'id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof GetTicketOutput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof GetTicketOutput
     */
    'organization_id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof GetTicketOutput
     */
    'event_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetTicketOutput
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetTicketOutput
     */
    'is_checked_in'?: boolean;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof GetTicketOutput
     */
    'ticket_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicketOutput
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTicketOutput
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface JoinRoomInput
 */
export interface JoinRoomInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof JoinRoomInput
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof JoinRoomInput
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface JoinRoomOutput
 */
export interface JoinRoomOutput {
    /**
     * 
     * @type {string}
     * @memberof JoinRoomOutput
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LeaveRoomInput
 */
export interface LeaveRoomInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof LeaveRoomInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof LeaveRoomInput
     */
    'ticket_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof LeaveRoomInput
     */
    'room_id': string;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PermissionType = {
    Public: 'public',
    Private: 'private',
    Protected: 'protected'
} as const;

export type PermissionType = typeof PermissionType[keyof typeof PermissionType];


/**
 * 
 * @export
 * @interface Promo
 */
export interface Promo {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Promo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Promo
     */
    'name': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Promo
     */
    'event_id': string;
    /**
     * 
     * @type {DiscountType}
     * @memberof Promo
     */
    'discount_type': DiscountType;
    /**
     * 
     * @type {string}
     * @memberof Promo
     */
    'discount_code': string;
    /**
     * 
     * @type {number}
     * @memberof Promo
     */
    'discount': number;
    /**
     * 
     * @type {boolean}
     * @memberof Promo
     */
    'is_stackable': boolean;
    /**
     * 
     * @type {Array<TicketType>}
     * @memberof Promo
     */
    'ticket_types': Array<TicketType>;
    /**
     * 
     * @type {boolean}
     * @memberof Promo
     */
    'is_active'?: boolean;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PublicExperienceInput = {
    Sunrise: 'SUNRISE',
    Topic: 'TOPIC',
    Custom: 'CUSTOM'
} as const;

export type PublicExperienceInput = typeof PublicExperienceInput[keyof typeof PublicExperienceInput];


/**
 * 
 * @export
 * @interface PublicTicket
 */
export interface PublicTicket {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PublicTicket
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PublicTicket
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PublicTicket
     */
    'organization_id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PublicTicket
     */
    'event_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicTicket
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicTicket
     */
    'is_checked_in'?: boolean;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof PublicTicket
     */
    'ticket_type_id': string;
}
/**
 * 
 * @export
 * @interface RaisedHand
 */
export interface RaisedHand {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof RaisedHand
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'created_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'modified_date'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Room
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Room
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'slug': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Room
     */
    'event_id': string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'scheduled_end_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'actual_end_date'?: string;
    /**
     * 
     * @type {ExperienceType}
     * @memberof Room
     */
    'experience_type': ExperienceType;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'topic_name': string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'topic_description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Room
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Room
     */
    'is_live'?: boolean;
}


/**
 * 
 * @export
 * @interface RoomAttendee
 */
export interface RoomAttendee {
    /**
     * 
     * @type {string}
     * @memberof RoomAttendee
     */
    'created_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomAttendee
     */
    'modified_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomAttendee
     */
    'is_active': boolean;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof RoomAttendee
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof RoomAttendee
     */
    'room_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof RoomAttendee
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof RoomAttendee
     */
    'event_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoomAttendee
     */
    'is_host': boolean;
}
/**
 * 
 * @export
 * @interface RoomStatsOutput
 */
export interface RoomStatsOutput {
    /**
     * 
     * @type {Room}
     * @memberof RoomStatsOutput
     */
    'room': Room;
    /**
     * 
     * @type {number}
     * @memberof RoomStatsOutput
     */
    'attendee_count': number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const TemporalRelation = {
    Future: 'future',
    Past: 'past'
} as const;

export type TemporalRelation = typeof TemporalRelation[keyof typeof TemporalRelation];


/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Ticket
     */
    'id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Ticket
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Ticket
     */
    'organization_id'?: string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Ticket
     */
    'event_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Ticket
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ticket
     */
    'is_checked_in'?: boolean;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof Ticket
     */
    'ticket_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof Ticket
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface TicketCheckoutData
 */
export interface TicketCheckoutData {
    /**
     * 
     * @type {string}
     * @memberof TicketCheckoutData
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketCheckoutData
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketCheckoutData
     */
    'email': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TicketCheckoutData
     */
    'ticket_type_id': string;
}
/**
 * Response model for ticket export endpoint (supports multi-event).
 * @export
 * @interface TicketExportResponse
 */
export interface TicketExportResponse {
    /**
     * 
     * @type {string}
     * @memberof TicketExportResponse
     */
    'file_url': string;
    /**
     * 
     * @type {string}
     * @memberof TicketExportResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketExportResponse
     */
    'event_ids': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TicketExportResponse
     */
    'total_events': number;
    /**
     * 
     * @type {number}
     * @memberof TicketExportResponse
     */
    'total_tickets': number;
}
/**
 * 
 * @export
 * @interface TicketTransferData
 */
export interface TicketTransferData {
    /**
     * 
     * @type {string}
     * @memberof TicketTransferData
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTransferData
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTransferData
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface TicketTransferOutput
 */
export interface TicketTransferOutput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TicketTransferOutput
     */
    'ticket_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TicketTransferOutput
     */
    'ticket_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof TicketTransferOutput
     */
    'recipient_email': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TicketTransferOutput
     */
    'recipient_user_id': string;
}
/**
 * 
 * @export
 * @interface TicketType
 */
export interface TicketType {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TicketType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TicketType
     */
    'description': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TicketType
     */
    'event_id': string;
    /**
     * 
     * @type {number}
     * @memberof TicketType
     */
    'price': number;
    /**
     * 
     * @type {boolean}
     * @memberof TicketType
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface TransferTicketInput
 */
export interface TransferTicketInput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TransferTicketInput
     */
    'event_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TransferTicketInput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TransferTicketInput
     */
    'ticket_id': string;
    /**
     * 
     * @type {TicketTransferData}
     * @memberof TransferTicketInput
     */
    'receiver_ticket': TicketTransferData;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof TransferTicketInput
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface UpdateTicketQuantityInput
 */
export interface UpdateTicketQuantityInput {
    /**
     * New quantity for the ticket, must be greater than 0
     * @type {number}
     * @memberof UpdateTicketQuantityInput
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface UpdateTicketQuantityOutput
 */
export interface UpdateTicketQuantityOutput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof UpdateTicketQuantityOutput
     */
    'ticket_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof UpdateTicketQuantityOutput
     */
    'user_id': string;
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof UpdateTicketQuantityOutput
     */
    'event_id': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTicketQuantityOutput
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface UserOnStage
 */
export interface UserOnStage {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof UserOnStage
     */
    'user_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOnStage
     */
    'is_host': boolean;
}
/**
 * 
 * @export
 * @interface UsersAtSameEventOutput
 */
export interface UsersAtSameEventOutput {
    /**
     * A unique identifier (UUID) in hexadecimal format
     * @type {string}
     * @memberof UsersAtSameEventOutput
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface ValidateMultiDiscountCodeInput
 */
export interface ValidateMultiDiscountCodeInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidateMultiDiscountCodeInput
     */
    'ticket_type_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get multiple events by their IDs with optional filtering by experience type.  If experience_type is specified, only events of that type will be returned. Any event IDs that don\'t exist or don\'t match the requested experience_type will be silently ignored.
         * @summary Bulk Get Events By Id
         * @param {BulkGetEventsInput} bulkGetEventsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkGetEventsByIdEventsBulkPost: async (bulkGetEventsInput: BulkGetEventsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkGetEventsInput' is not null or undefined
            assertParamExists('bulkGetEventsByIdEventsBulkPost', 'bulkGetEventsInput', bulkGetEventsInput)
            const localVarPath = `/events/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkGetEventsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel Event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEventEventsCancelEventIdPatch: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('cancelEventEventsCancelEventIdPatch', 'eventId', eventId)
            const localVarPath = `/events/cancel/{event_id}/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event
         * @param {CreateEventInput} createEventInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventEventsPost: async (createEventInput: CreateEventInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventInput' is not null or undefined
            assertParamExists('createEventEventsPost', 'createEventInput', createEventInput)
            const localVarPath = `/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event Location
         * @param {CreateEventLocationInput} createEventLocationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventLocationEventsLocationsPost: async (createEventLocationInput: CreateEventLocationInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventLocationInput' is not null or undefined
            assertParamExists('createEventLocationEventsLocationsPost', 'createEventLocationInput', createEventLocationInput)
            const localVarPath = `/events/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventLocationInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event Tags
         * @param {CreateEventTagsInput} createEventTagsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTagsEventsTagsPost: async (createEventTagsInput: CreateEventTagsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventTagsInput' is not null or undefined
            assertParamExists('createEventTagsEventsTagsPost', 'createEventTagsInput', createEventTagsInput)
            const localVarPath = `/events/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventTagsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event by ID. Admin-only endpoint.  Args:     event_id: The ID of the event to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteEventOutput: Response indicating success or failure
         * @summary Delete Event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventEventsEventIdDelete: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventEventsEventIdDelete', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventEventsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventEventsIdGet', 'id', id)
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Event Location
         * @param {string} eventLocationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLocationEventsLocationsEventLocationIdGet: async (eventLocationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventLocationId' is not null or undefined
            assertParamExists('getEventLocationEventsLocationsEventLocationIdGet', 'eventLocationId', eventLocationId)
            const localVarPath = `/events/locations/{event_location_id}/`
                .replace(`{${"event_location_id"}}`, encodeURIComponent(String(eventLocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Event Tags
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTagsEventsEventIdTagsGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventTagsEventsEventIdTagsGet', 'eventId', eventId)
            const localVarPath = `/events/{event_id}/tags/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Events By Type
         * @param {ExperienceType} eventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByTypeEventsTypeEventTypeGet: async (eventType: ExperienceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('getEventsByTypeEventsTypeEventTypeGet', 'eventType', eventType)
            const localVarPath = `/events/type/{event_type}/`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get events based on their temporal relation (FUTURE or PAST) with optional filtering.  Parameters: - temporal_relation: Filter events by FUTURE or PAST - experience_types: Optional list of experience types to filter by - organization_id: Optional parameter to filter events by a specific organization
         * @summary Get Events Temporal
         * @param {TemporalRelation} temporalRelation 
         * @param {Array<ExperienceType>} [experienceTypes] Types of experiences to filter by. PRIVATE_ROOM is only allowed when it\&#39;s the only experience type specified (will filter by current user).
         * @param {string} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsTemporalEventsTemporalTemporalRelationGet: async (temporalRelation: TemporalRelation, experienceTypes?: Array<ExperienceType>, organizationId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'temporalRelation' is not null or undefined
            assertParamExists('getEventsTemporalEventsTemporalTemporalRelationGet', 'temporalRelation', temporalRelation)
            const localVarPath = `/events/temporal/{temporal_relation}/`
                .replace(`{${"temporal_relation"}}`, encodeURIComponent(String(temporalRelation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)

            if (experienceTypes) {
                localVarQueryParameter['experience_types'] = experienceTypes;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organization_id'] = organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Future User Events
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFutureUserEventsEventsFutureUserUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFutureUserEventsEventsFutureUserUserIdGet', 'userId', userId)
            const localVarPath = `/events/future/user/{user_id}/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Next Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextEventEventsNextGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/next/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Event Locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventLocationsEventsLocationsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/locations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsEventsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventEventsPut: async (event: Event, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('updateEventEventsPut', 'event', event)
            const localVarPath = `/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get multiple events by their IDs with optional filtering by experience type.  If experience_type is specified, only events of that type will be returned. Any event IDs that don\'t exist or don\'t match the requested experience_type will be silently ignored.
         * @summary Bulk Get Events By Id
         * @param {BulkGetEventsInput} bulkGetEventsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkGetEventsByIdEventsBulkPost(bulkGetEventsInput: BulkGetEventsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkGetEventsByIdEventsBulkPost(bulkGetEventsInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.bulkGetEventsByIdEventsBulkPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel Event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelEventEventsCancelEventIdPatch(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelEventEventsCancelEventIdPatch(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.cancelEventEventsCancelEventIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event
         * @param {CreateEventInput} createEventInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventEventsPost(createEventInput: CreateEventInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventEventsPost(createEventInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEventEventsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event Location
         * @param {CreateEventLocationInput} createEventLocationInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventLocationEventsLocationsPost(createEventLocationInput: CreateEventLocationInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventLocationEventsLocationsPost(createEventLocationInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEventLocationEventsLocationsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event Tags
         * @param {CreateEventTagsInput} createEventTagsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTagsEventsTagsPost(createEventTagsInput: CreateEventTagsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTagsEventsTagsPost(createEventTagsInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.createEventTagsEventsTagsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete an event by ID. Admin-only endpoint.  Args:     event_id: The ID of the event to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteEventOutput: Response indicating success or failure
         * @summary Delete Event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventEventsEventIdDelete(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteEventOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventEventsEventIdDelete(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.deleteEventEventsEventIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Event
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventEventsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventEventsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventEventsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Event Location
         * @param {string} eventLocationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventLocationEventsLocationsEventLocationIdGet(eventLocationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventLocationEventsLocationsEventLocationIdGet(eventLocationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventLocationEventsLocationsEventLocationIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Event Tags
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTagsEventsEventIdTagsGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTagsEventsEventIdTagsGet(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventTagsEventsEventIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Events By Type
         * @param {ExperienceType} eventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsByTypeEventsTypeEventTypeGet(eventType: ExperienceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsByTypeEventsTypeEventTypeGet(eventType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventsByTypeEventsTypeEventTypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get events based on their temporal relation (FUTURE or PAST) with optional filtering.  Parameters: - temporal_relation: Filter events by FUTURE or PAST - experience_types: Optional list of experience types to filter by - organization_id: Optional parameter to filter events by a specific organization
         * @summary Get Events Temporal
         * @param {TemporalRelation} temporalRelation 
         * @param {Array<ExperienceType>} [experienceTypes] Types of experiences to filter by. PRIVATE_ROOM is only allowed when it\&#39;s the only experience type specified (will filter by current user).
         * @param {string} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsTemporalEventsTemporalTemporalRelationGet(temporalRelation: TemporalRelation, experienceTypes?: Array<ExperienceType>, organizationId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsTemporalEventsTemporalTemporalRelationGet(temporalRelation, experienceTypes, organizationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getEventsTemporalEventsTemporalTemporalRelationGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Future User Events
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFutureUserEventsEventsFutureUserUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFutureUserEventsEventsFutureUserUserIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getFutureUserEventsEventsFutureUserUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Next Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextEventEventsNextGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextEventEventsNextGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.getNextEventEventsNextGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Event Locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventLocationsEventsLocationsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventLocationsEventsLocationsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.listEventLocationsEventsLocationsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventsEventsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventsEventsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.listEventsEventsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update Event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventEventsPut(event: Event, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventEventsPut(event, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EventsApi.updateEventEventsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Get multiple events by their IDs with optional filtering by experience type.  If experience_type is specified, only events of that type will be returned. Any event IDs that don\'t exist or don\'t match the requested experience_type will be silently ignored.
         * @summary Bulk Get Events By Id
         * @param {EventsApiBulkGetEventsByIdEventsBulkPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkGetEventsByIdEventsBulkPost(requestParameters: EventsApiBulkGetEventsByIdEventsBulkPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.bulkGetEventsByIdEventsBulkPost(requestParameters.bulkGetEventsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel Event
         * @param {EventsApiCancelEventEventsCancelEventIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelEventEventsCancelEventIdPatch(requestParameters: EventsApiCancelEventEventsCancelEventIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.cancelEventEventsCancelEventIdPatch(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event
         * @param {EventsApiCreateEventEventsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventEventsPost(requestParameters: EventsApiCreateEventEventsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.createEventEventsPost(requestParameters.createEventInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event Location
         * @param {EventsApiCreateEventLocationEventsLocationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventLocationEventsLocationsPost(requestParameters: EventsApiCreateEventLocationEventsLocationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<EventLocation> {
            return localVarFp.createEventLocationEventsLocationsPost(requestParameters.createEventLocationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event Tags
         * @param {EventsApiCreateEventTagsEventsTagsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTagsEventsTagsPost(requestParameters: EventsApiCreateEventTagsEventsTagsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventTag>> {
            return localVarFp.createEventTagsEventsTagsPost(requestParameters.createEventTagsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event by ID. Admin-only endpoint.  Args:     event_id: The ID of the event to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteEventOutput: Response indicating success or failure
         * @summary Delete Event
         * @param {EventsApiDeleteEventEventsEventIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventEventsEventIdDelete(requestParameters: EventsApiDeleteEventEventsEventIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteEventOutput> {
            return localVarFp.deleteEventEventsEventIdDelete(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Event
         * @param {EventsApiGetEventEventsIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventEventsIdGet(requestParameters: EventsApiGetEventEventsIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getEventEventsIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Event Location
         * @param {EventsApiGetEventLocationEventsLocationsEventLocationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLocationEventsLocationsEventLocationIdGet(requestParameters: EventsApiGetEventLocationEventsLocationsEventLocationIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<EventLocation> {
            return localVarFp.getEventLocationEventsLocationsEventLocationIdGet(requestParameters.eventLocationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Event Tags
         * @param {EventsApiGetEventTagsEventsEventIdTagsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTagsEventsEventIdTagsGet(requestParameters: EventsApiGetEventTagsEventsEventIdTagsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventTag>> {
            return localVarFp.getEventTagsEventsEventIdTagsGet(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Events By Type
         * @param {EventsApiGetEventsByTypeEventsTypeEventTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByTypeEventsTypeEventTypeGet(requestParameters: EventsApiGetEventsByTypeEventsTypeEventTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.getEventsByTypeEventsTypeEventTypeGet(requestParameters.eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get events based on their temporal relation (FUTURE or PAST) with optional filtering.  Parameters: - temporal_relation: Filter events by FUTURE or PAST - experience_types: Optional list of experience types to filter by - organization_id: Optional parameter to filter events by a specific organization
         * @summary Get Events Temporal
         * @param {EventsApiGetEventsTemporalEventsTemporalTemporalRelationGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsTemporalEventsTemporalTemporalRelationGet(requestParameters: EventsApiGetEventsTemporalEventsTemporalTemporalRelationGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.getEventsTemporalEventsTemporalTemporalRelationGet(requestParameters.temporalRelation, requestParameters.experienceTypes, requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Future User Events
         * @param {EventsApiGetFutureUserEventsEventsFutureUserUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFutureUserEventsEventsFutureUserUserIdGet(requestParameters: EventsApiGetFutureUserEventsEventsFutureUserUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.getFutureUserEventsEventsFutureUserUserIdGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Next Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextEventEventsNextGet(options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getNextEventEventsNextGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Event Locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventLocationsEventsLocationsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<EventLocation>> {
            return localVarFp.listEventLocationsEventsLocationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsEventsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.listEventsEventsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Event
         * @param {EventsApiUpdateEventEventsPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventEventsPut(requestParameters: EventsApiUpdateEventEventsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.updateEventEventsPut(requestParameters.event, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkGetEventsByIdEventsBulkPost operation in EventsApi.
 * @export
 * @interface EventsApiBulkGetEventsByIdEventsBulkPostRequest
 */
export interface EventsApiBulkGetEventsByIdEventsBulkPostRequest {
    /**
     * 
     * @type {BulkGetEventsInput}
     * @memberof EventsApiBulkGetEventsByIdEventsBulkPost
     */
    readonly bulkGetEventsInput: BulkGetEventsInput
}

/**
 * Request parameters for cancelEventEventsCancelEventIdPatch operation in EventsApi.
 * @export
 * @interface EventsApiCancelEventEventsCancelEventIdPatchRequest
 */
export interface EventsApiCancelEventEventsCancelEventIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiCancelEventEventsCancelEventIdPatch
     */
    readonly eventId: string
}

/**
 * Request parameters for createEventEventsPost operation in EventsApi.
 * @export
 * @interface EventsApiCreateEventEventsPostRequest
 */
export interface EventsApiCreateEventEventsPostRequest {
    /**
     * 
     * @type {CreateEventInput}
     * @memberof EventsApiCreateEventEventsPost
     */
    readonly createEventInput: CreateEventInput
}

/**
 * Request parameters for createEventLocationEventsLocationsPost operation in EventsApi.
 * @export
 * @interface EventsApiCreateEventLocationEventsLocationsPostRequest
 */
export interface EventsApiCreateEventLocationEventsLocationsPostRequest {
    /**
     * 
     * @type {CreateEventLocationInput}
     * @memberof EventsApiCreateEventLocationEventsLocationsPost
     */
    readonly createEventLocationInput: CreateEventLocationInput
}

/**
 * Request parameters for createEventTagsEventsTagsPost operation in EventsApi.
 * @export
 * @interface EventsApiCreateEventTagsEventsTagsPostRequest
 */
export interface EventsApiCreateEventTagsEventsTagsPostRequest {
    /**
     * 
     * @type {CreateEventTagsInput}
     * @memberof EventsApiCreateEventTagsEventsTagsPost
     */
    readonly createEventTagsInput: CreateEventTagsInput
}

/**
 * Request parameters for deleteEventEventsEventIdDelete operation in EventsApi.
 * @export
 * @interface EventsApiDeleteEventEventsEventIdDeleteRequest
 */
export interface EventsApiDeleteEventEventsEventIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiDeleteEventEventsEventIdDelete
     */
    readonly eventId: string
}

/**
 * Request parameters for getEventEventsIdGet operation in EventsApi.
 * @export
 * @interface EventsApiGetEventEventsIdGetRequest
 */
export interface EventsApiGetEventEventsIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiGetEventEventsIdGet
     */
    readonly id: string
}

/**
 * Request parameters for getEventLocationEventsLocationsEventLocationIdGet operation in EventsApi.
 * @export
 * @interface EventsApiGetEventLocationEventsLocationsEventLocationIdGetRequest
 */
export interface EventsApiGetEventLocationEventsLocationsEventLocationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiGetEventLocationEventsLocationsEventLocationIdGet
     */
    readonly eventLocationId: string
}

/**
 * Request parameters for getEventTagsEventsEventIdTagsGet operation in EventsApi.
 * @export
 * @interface EventsApiGetEventTagsEventsEventIdTagsGetRequest
 */
export interface EventsApiGetEventTagsEventsEventIdTagsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiGetEventTagsEventsEventIdTagsGet
     */
    readonly eventId: string
}

/**
 * Request parameters for getEventsByTypeEventsTypeEventTypeGet operation in EventsApi.
 * @export
 * @interface EventsApiGetEventsByTypeEventsTypeEventTypeGetRequest
 */
export interface EventsApiGetEventsByTypeEventsTypeEventTypeGetRequest {
    /**
     * 
     * @type {ExperienceType}
     * @memberof EventsApiGetEventsByTypeEventsTypeEventTypeGet
     */
    readonly eventType: ExperienceType
}

/**
 * Request parameters for getEventsTemporalEventsTemporalTemporalRelationGet operation in EventsApi.
 * @export
 * @interface EventsApiGetEventsTemporalEventsTemporalTemporalRelationGetRequest
 */
export interface EventsApiGetEventsTemporalEventsTemporalTemporalRelationGetRequest {
    /**
     * 
     * @type {TemporalRelation}
     * @memberof EventsApiGetEventsTemporalEventsTemporalTemporalRelationGet
     */
    readonly temporalRelation: TemporalRelation

    /**
     * Types of experiences to filter by. PRIVATE_ROOM is only allowed when it\&#39;s the only experience type specified (will filter by current user).
     * @type {Array<ExperienceType>}
     * @memberof EventsApiGetEventsTemporalEventsTemporalTemporalRelationGet
     */
    readonly experienceTypes?: Array<ExperienceType>

    /**
     * 
     * @type {string}
     * @memberof EventsApiGetEventsTemporalEventsTemporalTemporalRelationGet
     */
    readonly organizationId?: string
}

/**
 * Request parameters for getFutureUserEventsEventsFutureUserUserIdGet operation in EventsApi.
 * @export
 * @interface EventsApiGetFutureUserEventsEventsFutureUserUserIdGetRequest
 */
export interface EventsApiGetFutureUserEventsEventsFutureUserUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiGetFutureUserEventsEventsFutureUserUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for updateEventEventsPut operation in EventsApi.
 * @export
 * @interface EventsApiUpdateEventEventsPutRequest
 */
export interface EventsApiUpdateEventEventsPutRequest {
    /**
     * 
     * @type {Event}
     * @memberof EventsApiUpdateEventEventsPut
     */
    readonly event: Event
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Get multiple events by their IDs with optional filtering by experience type.  If experience_type is specified, only events of that type will be returned. Any event IDs that don\'t exist or don\'t match the requested experience_type will be silently ignored.
     * @summary Bulk Get Events By Id
     * @param {EventsApiBulkGetEventsByIdEventsBulkPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public bulkGetEventsByIdEventsBulkPost(requestParameters: EventsApiBulkGetEventsByIdEventsBulkPostRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).bulkGetEventsByIdEventsBulkPost(requestParameters.bulkGetEventsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel Event
     * @param {EventsApiCancelEventEventsCancelEventIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public cancelEventEventsCancelEventIdPatch(requestParameters: EventsApiCancelEventEventsCancelEventIdPatchRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).cancelEventEventsCancelEventIdPatch(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event
     * @param {EventsApiCreateEventEventsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventEventsPost(requestParameters: EventsApiCreateEventEventsPostRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventEventsPost(requestParameters.createEventInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event Location
     * @param {EventsApiCreateEventLocationEventsLocationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventLocationEventsLocationsPost(requestParameters: EventsApiCreateEventLocationEventsLocationsPostRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventLocationEventsLocationsPost(requestParameters.createEventLocationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event Tags
     * @param {EventsApiCreateEventTagsEventsTagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventTagsEventsTagsPost(requestParameters: EventsApiCreateEventTagsEventsTagsPostRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventTagsEventsTagsPost(requestParameters.createEventTagsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event by ID. Admin-only endpoint.  Args:     event_id: The ID of the event to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteEventOutput: Response indicating success or failure
     * @summary Delete Event
     * @param {EventsApiDeleteEventEventsEventIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventEventsEventIdDelete(requestParameters: EventsApiDeleteEventEventsEventIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventEventsEventIdDelete(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Event
     * @param {EventsApiGetEventEventsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventEventsIdGet(requestParameters: EventsApiGetEventEventsIdGetRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventEventsIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Event Location
     * @param {EventsApiGetEventLocationEventsLocationsEventLocationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventLocationEventsLocationsEventLocationIdGet(requestParameters: EventsApiGetEventLocationEventsLocationsEventLocationIdGetRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventLocationEventsLocationsEventLocationIdGet(requestParameters.eventLocationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Event Tags
     * @param {EventsApiGetEventTagsEventsEventIdTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventTagsEventsEventIdTagsGet(requestParameters: EventsApiGetEventTagsEventsEventIdTagsGetRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventTagsEventsEventIdTagsGet(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Events By Type
     * @param {EventsApiGetEventsByTypeEventsTypeEventTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventsByTypeEventsTypeEventTypeGet(requestParameters: EventsApiGetEventsByTypeEventsTypeEventTypeGetRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventsByTypeEventsTypeEventTypeGet(requestParameters.eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get events based on their temporal relation (FUTURE or PAST) with optional filtering.  Parameters: - temporal_relation: Filter events by FUTURE or PAST - experience_types: Optional list of experience types to filter by - organization_id: Optional parameter to filter events by a specific organization
     * @summary Get Events Temporal
     * @param {EventsApiGetEventsTemporalEventsTemporalTemporalRelationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventsTemporalEventsTemporalTemporalRelationGet(requestParameters: EventsApiGetEventsTemporalEventsTemporalTemporalRelationGetRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventsTemporalEventsTemporalTemporalRelationGet(requestParameters.temporalRelation, requestParameters.experienceTypes, requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Future User Events
     * @param {EventsApiGetFutureUserEventsEventsFutureUserUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getFutureUserEventsEventsFutureUserUserIdGet(requestParameters: EventsApiGetFutureUserEventsEventsFutureUserUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getFutureUserEventsEventsFutureUserUserIdGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Next Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getNextEventEventsNextGet(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getNextEventEventsNextGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Event Locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventLocationsEventsLocationsGet(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventLocationsEventsLocationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventsEventsGet(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventsEventsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Event
     * @param {EventsApiUpdateEventEventsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventEventsPut(requestParameters: EventsApiUpdateEventEventsPutRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventEventsPut(requestParameters.event, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromosApi - axios parameter creator
 * @export
 */
export const PromosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Promo
         * @param {CreatePromoInput} createPromoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromoPromosPost: async (createPromoInput: CreatePromoInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPromoInput' is not null or undefined
            assertParamExists('createPromoPromosPost', 'createPromoInput', createPromoInput)
            const localVarPath = `/promos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromoInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Promo
         * @param {string} promoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromoPromosPromoIdGet: async (promoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoId' is not null or undefined
            assertParamExists('getPromoPromosPromoIdGet', 'promoId', promoId)
            const localVarPath = `/promos/{promo_id}/`
                .replace(`{${"promo_id"}}`, encodeURIComponent(String(promoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Promos By Event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromosByEventPromosEventsEventIdGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getPromosByEventPromosEventsEventIdGet', 'eventId', eventId)
            const localVarPath = `/promos/events/{event_id}/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Promos By Organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromosByOrganizationPromosOrganizationsOrganizationIdGet: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getPromosByOrganizationPromosOrganizationsOrganizationIdGet', 'organizationId', organizationId)
            const localVarPath = `/promos/organizations/{organization_id}/`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Promos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromosPromosGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/promos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Promo
         * @param {string} promoId 
         * @param {CreatePromoInput} createPromoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromoPromosPromoIdPut: async (promoId: string, createPromoInput: CreatePromoInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoId' is not null or undefined
            assertParamExists('updatePromoPromosPromoIdPut', 'promoId', promoId)
            // verify required parameter 'createPromoInput' is not null or undefined
            assertParamExists('updatePromoPromosPromoIdPut', 'createPromoInput', createPromoInput)
            const localVarPath = `/promos/{promo_id}/`
                .replace(`{${"promo_id"}}`, encodeURIComponent(String(promoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromoInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a discount code against multiple ticket types.  Args:     request: The HTTP request     ticket_type_ids: List of ticket type IDs to validate against     discount_code: The discount code to validate     current_user: The authenticated user     db: Database session      Returns:     Promo object if found and valid
         * @summary Validate Discount Code For Multiple Ticket Types
         * @param {string} discountCode 
         * @param {ValidateMultiDiscountCodeInput} validateMultiDiscountCodeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost: async (discountCode: string, validateMultiDiscountCodeInput: ValidateMultiDiscountCodeInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discountCode' is not null or undefined
            assertParamExists('validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost', 'discountCode', discountCode)
            // verify required parameter 'validateMultiDiscountCodeInput' is not null or undefined
            assertParamExists('validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost', 'validateMultiDiscountCodeInput', validateMultiDiscountCodeInput)
            const localVarPath = `/promos/validate/{discount_code}/`
                .replace(`{${"discount_code"}}`, encodeURIComponent(String(discountCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateMultiDiscountCodeInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Discount Code For Ticket Type
         * @param {string} ticketTypeId 
         * @param {string} discountCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet: async (ticketTypeId: string, discountCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketTypeId' is not null or undefined
            assertParamExists('validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet', 'ticketTypeId', ticketTypeId)
            // verify required parameter 'discountCode' is not null or undefined
            assertParamExists('validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet', 'discountCode', discountCode)
            const localVarPath = `/promos/tickets/type/{ticket_type_id}/validate/{discount_code}/`
                .replace(`{${"ticket_type_id"}}`, encodeURIComponent(String(ticketTypeId)))
                .replace(`{${"discount_code"}}`, encodeURIComponent(String(discountCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromosApi - functional programming interface
 * @export
 */
export const PromosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Promo
         * @param {CreatePromoInput} createPromoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPromoPromosPost(createPromoInput: CreatePromoInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Promo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPromoPromosPost(createPromoInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.createPromoPromosPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Promo
         * @param {string} promoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromoPromosPromoIdGet(promoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Promo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromoPromosPromoIdGet(promoId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.getPromoPromosPromoIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Promos By Event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromosByEventPromosEventsEventIdGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Promo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromosByEventPromosEventsEventIdGet(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.getPromosByEventPromosEventsEventIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Promos By Organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromosByOrganizationPromosOrganizationsOrganizationIdGet(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Promo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromosByOrganizationPromosOrganizationsOrganizationIdGet(organizationId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.getPromosByOrganizationPromosOrganizationsOrganizationIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Promos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromosPromosGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Promo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPromosPromosGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.listPromosPromosGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Update Promo
         * @param {string} promoId 
         * @param {CreatePromoInput} createPromoInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePromoPromosPromoIdPut(promoId: string, createPromoInput: CreatePromoInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Promo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePromoPromosPromoIdPut(promoId, createPromoInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.updatePromoPromosPromoIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Validate a discount code against multiple ticket types.  Args:     request: The HTTP request     ticket_type_ids: List of ticket type IDs to validate against     discount_code: The discount code to validate     current_user: The authenticated user     db: Database session      Returns:     Promo object if found and valid
         * @summary Validate Discount Code For Multiple Ticket Types
         * @param {string} discountCode 
         * @param {ValidateMultiDiscountCodeInput} validateMultiDiscountCodeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost(discountCode: string, validateMultiDiscountCodeInput: ValidateMultiDiscountCodeInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Promo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost(discountCode, validateMultiDiscountCodeInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Validate Discount Code For Ticket Type
         * @param {string} ticketTypeId 
         * @param {string} discountCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet(ticketTypeId: string, discountCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Promo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet(ticketTypeId, discountCode, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PromosApi.validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PromosApi - factory interface
 * @export
 */
export const PromosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromosApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Promo
         * @param {PromosApiCreatePromoPromosPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromoPromosPost(requestParameters: PromosApiCreatePromoPromosPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Promo> {
            return localVarFp.createPromoPromosPost(requestParameters.createPromoInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Promo
         * @param {PromosApiGetPromoPromosPromoIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromoPromosPromoIdGet(requestParameters: PromosApiGetPromoPromosPromoIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Promo> {
            return localVarFp.getPromoPromosPromoIdGet(requestParameters.promoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Promos By Event
         * @param {PromosApiGetPromosByEventPromosEventsEventIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromosByEventPromosEventsEventIdGet(requestParameters: PromosApiGetPromosByEventPromosEventsEventIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Promo>> {
            return localVarFp.getPromosByEventPromosEventsEventIdGet(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Promos By Organization
         * @param {PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromosByOrganizationPromosOrganizationsOrganizationIdGet(requestParameters: PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Promo>> {
            return localVarFp.getPromosByOrganizationPromosOrganizationsOrganizationIdGet(requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Promos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromosPromosGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Promo>> {
            return localVarFp.listPromosPromosGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Promo
         * @param {PromosApiUpdatePromoPromosPromoIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromoPromosPromoIdPut(requestParameters: PromosApiUpdatePromoPromosPromoIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Promo> {
            return localVarFp.updatePromoPromosPromoIdPut(requestParameters.promoId, requestParameters.createPromoInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a discount code against multiple ticket types.  Args:     request: The HTTP request     ticket_type_ids: List of ticket type IDs to validate against     discount_code: The discount code to validate     current_user: The authenticated user     db: Database session      Returns:     Promo object if found and valid
         * @summary Validate Discount Code For Multiple Ticket Types
         * @param {PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost(requestParameters: PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Promo>> {
            return localVarFp.validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost(requestParameters.discountCode, requestParameters.validateMultiDiscountCodeInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Discount Code For Ticket Type
         * @param {PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet(requestParameters: PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Promo> {
            return localVarFp.validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet(requestParameters.ticketTypeId, requestParameters.discountCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPromoPromosPost operation in PromosApi.
 * @export
 * @interface PromosApiCreatePromoPromosPostRequest
 */
export interface PromosApiCreatePromoPromosPostRequest {
    /**
     * 
     * @type {CreatePromoInput}
     * @memberof PromosApiCreatePromoPromosPost
     */
    readonly createPromoInput: CreatePromoInput
}

/**
 * Request parameters for getPromoPromosPromoIdGet operation in PromosApi.
 * @export
 * @interface PromosApiGetPromoPromosPromoIdGetRequest
 */
export interface PromosApiGetPromoPromosPromoIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PromosApiGetPromoPromosPromoIdGet
     */
    readonly promoId: string
}

/**
 * Request parameters for getPromosByEventPromosEventsEventIdGet operation in PromosApi.
 * @export
 * @interface PromosApiGetPromosByEventPromosEventsEventIdGetRequest
 */
export interface PromosApiGetPromosByEventPromosEventsEventIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PromosApiGetPromosByEventPromosEventsEventIdGet
     */
    readonly eventId: string
}

/**
 * Request parameters for getPromosByOrganizationPromosOrganizationsOrganizationIdGet operation in PromosApi.
 * @export
 * @interface PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGetRequest
 */
export interface PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGet
     */
    readonly organizationId: string
}

/**
 * Request parameters for updatePromoPromosPromoIdPut operation in PromosApi.
 * @export
 * @interface PromosApiUpdatePromoPromosPromoIdPutRequest
 */
export interface PromosApiUpdatePromoPromosPromoIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof PromosApiUpdatePromoPromosPromoIdPut
     */
    readonly promoId: string

    /**
     * 
     * @type {CreatePromoInput}
     * @memberof PromosApiUpdatePromoPromosPromoIdPut
     */
    readonly createPromoInput: CreatePromoInput
}

/**
 * Request parameters for validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost operation in PromosApi.
 * @export
 * @interface PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePostRequest
 */
export interface PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePostRequest {
    /**
     * 
     * @type {string}
     * @memberof PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost
     */
    readonly discountCode: string

    /**
     * 
     * @type {ValidateMultiDiscountCodeInput}
     * @memberof PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost
     */
    readonly validateMultiDiscountCodeInput: ValidateMultiDiscountCodeInput
}

/**
 * Request parameters for validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet operation in PromosApi.
 * @export
 * @interface PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGetRequest
 */
export interface PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet
     */
    readonly ticketTypeId: string

    /**
     * 
     * @type {string}
     * @memberof PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet
     */
    readonly discountCode: string
}

/**
 * PromosApi - object-oriented interface
 * @export
 * @class PromosApi
 * @extends {BaseAPI}
 */
export class PromosApi extends BaseAPI {
    /**
     * 
     * @summary Create Promo
     * @param {PromosApiCreatePromoPromosPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public createPromoPromosPost(requestParameters: PromosApiCreatePromoPromosPostRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).createPromoPromosPost(requestParameters.createPromoInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Promo
     * @param {PromosApiGetPromoPromosPromoIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public getPromoPromosPromoIdGet(requestParameters: PromosApiGetPromoPromosPromoIdGetRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).getPromoPromosPromoIdGet(requestParameters.promoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Promos By Event
     * @param {PromosApiGetPromosByEventPromosEventsEventIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public getPromosByEventPromosEventsEventIdGet(requestParameters: PromosApiGetPromosByEventPromosEventsEventIdGetRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).getPromosByEventPromosEventsEventIdGet(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Promos By Organization
     * @param {PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public getPromosByOrganizationPromosOrganizationsOrganizationIdGet(requestParameters: PromosApiGetPromosByOrganizationPromosOrganizationsOrganizationIdGetRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).getPromosByOrganizationPromosOrganizationsOrganizationIdGet(requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Promos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public listPromosPromosGet(options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).listPromosPromosGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Promo
     * @param {PromosApiUpdatePromoPromosPromoIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public updatePromoPromosPromoIdPut(requestParameters: PromosApiUpdatePromoPromosPromoIdPutRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).updatePromoPromosPromoIdPut(requestParameters.promoId, requestParameters.createPromoInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a discount code against multiple ticket types.  Args:     request: The HTTP request     ticket_type_ids: List of ticket type IDs to validate against     discount_code: The discount code to validate     current_user: The authenticated user     db: Database session      Returns:     Promo object if found and valid
     * @summary Validate Discount Code For Multiple Ticket Types
     * @param {PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost(requestParameters: PromosApiValidateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePostRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).validateDiscountCodeForMultipleTicketTypesPromosValidateDiscountCodePost(requestParameters.discountCode, requestParameters.validateMultiDiscountCodeInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate Discount Code For Ticket Type
     * @param {PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromosApi
     */
    public validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet(requestParameters: PromosApiValidateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGetRequest, options?: RawAxiosRequestConfig) {
        return PromosApiFp(this.configuration).validateDiscountCodeForTicketTypePromosTicketsTypeTicketTypeIdValidateDiscountCodeGet(requestParameters.ticketTypeId, requestParameters.discountCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept Next Raised Hand
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/accept-raised-hand/next/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept User Raised Hand
         * @param {string} roomId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost: async (roomId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost', 'roomId', roomId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost', 'userId', userId)
            const localVarPath = `/rooms/{room_id}/accept-raised-hand/user/{user_id}/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk Get Room By Event Ids
         * @param {Array<string>} eventIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkGetRoomByEventIdsRoomsBulkGet: async (eventIds: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventIds' is not null or undefined
            assertParamExists('bulkGetRoomByEventIdsRoomsBulkGet', 'eventIds', eventIds)
            const localVarPath = `/rooms/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)

            if (eventIds) {
                localVarQueryParameter['event_ids'] = eventIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close Active Rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeActiveRoomsRoomsCloseActivePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/close-active/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Room
         * @param {CreateRoomInput} createRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomRoomsPost: async (createRoomInput: CreateRoomInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomInput' is not null or undefined
            assertParamExists('createRoomRoomsPost', 'createRoomInput', createRoomInput)
            const localVarPath = `/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Video Room
         * @param {CreateVideoRoomInput} createVideoRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideoRoomRoomsVideoRoomPost: async (createVideoRoomInput: CreateVideoRoomInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVideoRoomInput' is not null or undefined
            assertParamExists('createVideoRoomRoomsVideoRoomPost', 'createVideoRoomInput', createVideoRoomInput)
            const localVarPath = `/rooms/video-room/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVideoRoomInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Attendee Count
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttendeeCountRoomsRoomIdAttendeesCountGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getAttendeeCountRoomsRoomIdAttendeesCountGet', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/attendees/count/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Next Public Room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextPublicRoomRoomsNextGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms/next/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Public Rooms Temporal
         * @param {TemporalRelation} temporalRelation 
         * @param {Array<PublicExperienceInput>} experienceTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicRoomsTemporalRoomsPublicTemporalGet: async (temporalRelation: TemporalRelation, experienceTypes: Array<PublicExperienceInput>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'temporalRelation' is not null or undefined
            assertParamExists('getPublicRoomsTemporalRoomsPublicTemporalGet', 'temporalRelation', temporalRelation)
            // verify required parameter 'experienceTypes' is not null or undefined
            assertParamExists('getPublicRoomsTemporalRoomsPublicTemporalGet', 'experienceTypes', experienceTypes)
            const localVarPath = `/rooms/public/temporal/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)

            if (temporalRelation !== undefined) {
                localVarQueryParameter['temporal_relation'] = temporalRelation;
            }

            if (experienceTypes) {
                localVarQueryParameter['experience_types'] = experienceTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Raised Hand List
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaisedHandListRoomsRoomIdRaisedHandsGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRaisedHandListRoomsRoomIdRaisedHandsGet', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/raised-hands/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Room By Experience Type
         * @param {ExperienceType} experienceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet: async (experienceType: ExperienceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'experienceType' is not null or undefined
            assertParamExists('getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet', 'experienceType', experienceType)
            const localVarPath = `/rooms/experience-type/{experience_type}/`
                .replace(`{${"experience_type"}}`, encodeURIComponent(String(experienceType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomRoomsRoomIdGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoomRoomsRoomIdGet', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Room Stats
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomStatsRoomsRoomIdStatsGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoomStatsRoomsRoomIdStatsGet', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/stats/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users On Stage
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersOnStageRoomsRoomIdAttendeesOnStageGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getUsersOnStageRoomsRoomIdAttendeesOnStageGet', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/attendees-on-stage/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join Stage
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStageRoomsRoomIdJoinStagePost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('joinStageRoomsRoomIdJoinStagePost', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/join-stage/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join Video Room
         * @param {JoinRoomInput} joinRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinVideoRoomRoomsJoinPost: async (joinRoomInput: JoinRoomInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'joinRoomInput' is not null or undefined
            assertParamExists('joinVideoRoomRoomsJoinPost', 'joinRoomInput', joinRoomInput)
            const localVarPath = `/rooms/join/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinRoomInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave Room
         * @param {LeaveRoomInput} leaveRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoomRoomsLeavePost: async (leaveRoomInput: LeaveRoomInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaveRoomInput' is not null or undefined
            assertParamExists('leaveRoomRoomsLeavePost', 'leaveRoomInput', leaveRoomInput)
            const localVarPath = `/rooms/leave/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leaveRoomInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave Stage
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveStageRoomsRoomIdLeaveStagePost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('leaveStageRoomsRoomIdLeaveStagePost', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/leave-stage/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Room Attendees
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomAttendeesRoomsRoomIdAttendeesGet: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listRoomAttendeesRoomsRoomIdAttendeesGet', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/attendees/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Rooms By Event Id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsByEventIdRoomsEventsEventIdGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('listRoomsByEventIdRoomsEventsEventIdGet', 'eventId', eventId)
            const localVarPath = `/rooms/events/{event_id}/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lower Hand
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lowerHandRoomsRoomIdLowerHandPost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('lowerHandRoomsRoomIdLowerHandPost', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/lower-hand/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Raise Hand
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raiseHandRoomsRoomIdRaiseHandPost: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('raiseHandRoomsRoomIdRaiseHandPost', 'roomId', roomId)
            const localVarPath = `/rooms/{room_id}/raise-hand/`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept Next Raised Hand
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Accept User Raised Hand
         * @param {string} roomId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost(roomId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost(roomId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk Get Room By Event Ids
         * @param {Array<string>} eventIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkGetRoomByEventIdsRoomsBulkGet(eventIds: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Room>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkGetRoomByEventIdsRoomsBulkGet(eventIds, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.bulkGetRoomByEventIdsRoomsBulkGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Close Active Rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeActiveRoomsRoomsCloseActivePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeActiveRoomsRoomsCloseActivePost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.closeActiveRoomsRoomsCloseActivePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Room
         * @param {CreateRoomInput} createRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoomRoomsPost(createRoomInput: CreateRoomInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoomOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoomRoomsPost(createRoomInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.createRoomRoomsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Video Room
         * @param {CreateVideoRoomInput} createVideoRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVideoRoomRoomsVideoRoomPost(createVideoRoomInput: CreateVideoRoomInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoomOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVideoRoomRoomsVideoRoomPost(createVideoRoomInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.createVideoRoomRoomsVideoRoomPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Attendee Count
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttendeeCountRoomsRoomIdAttendeesCountGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendeeCountOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttendeeCountRoomsRoomIdAttendeesCountGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getAttendeeCountRoomsRoomIdAttendeesCountGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Next Public Room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextPublicRoomRoomsNextGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextPublicRoomRoomsNextGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getNextPublicRoomRoomsNextGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Public Rooms Temporal
         * @param {TemporalRelation} temporalRelation 
         * @param {Array<PublicExperienceInput>} experienceTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicRoomsTemporalRoomsPublicTemporalGet(temporalRelation: TemporalRelation, experienceTypes: Array<PublicExperienceInput>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Room>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicRoomsTemporalRoomsPublicTemporalGet(temporalRelation, experienceTypes, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getPublicRoomsTemporalRoomsPublicTemporalGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Raised Hand List
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaisedHandListRoomsRoomIdRaisedHandsGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RaisedHand>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaisedHandListRoomsRoomIdRaisedHandsGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getRaisedHandListRoomsRoomIdRaisedHandsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Room By Experience Type
         * @param {ExperienceType} experienceType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet(experienceType: ExperienceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Room>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet(experienceType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomRoomsRoomIdGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomRoomsRoomIdGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getRoomRoomsRoomIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Room Stats
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomStatsRoomsRoomIdStatsGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomStatsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomStatsRoomsRoomIdStatsGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getRoomStatsRoomsRoomIdStatsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Users On Stage
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersOnStageRoomsRoomIdAttendeesOnStageGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOnStage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersOnStageRoomsRoomIdAttendeesOnStageGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.getUsersOnStageRoomsRoomIdAttendeesOnStageGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Join Stage
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinStageRoomsRoomIdJoinStagePost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinStageRoomsRoomIdJoinStagePost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.joinStageRoomsRoomIdJoinStagePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Join Video Room
         * @param {JoinRoomInput} joinRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinVideoRoomRoomsJoinPost(joinRoomInput: JoinRoomInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JoinRoomOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinVideoRoomRoomsJoinPost(joinRoomInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.joinVideoRoomRoomsJoinPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Leave Room
         * @param {LeaveRoomInput} leaveRoomInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveRoomRoomsLeavePost(leaveRoomInput: LeaveRoomInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveRoomRoomsLeavePost(leaveRoomInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.leaveRoomRoomsLeavePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Leave Stage
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveStageRoomsRoomIdLeaveStagePost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveStageRoomsRoomIdLeaveStagePost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.leaveStageRoomsRoomIdLeaveStagePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Room Attendees
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomAttendeesRoomsRoomIdAttendeesGet(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomAttendee>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomAttendeesRoomsRoomIdAttendeesGet(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.listRoomAttendeesRoomsRoomIdAttendeesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary List Rooms By Event Id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomsByEventIdRoomsEventsEventIdGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Room>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomsByEventIdRoomsEventsEventIdGet(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.listRoomsByEventIdRoomsEventsEventIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Lower Hand
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lowerHandRoomsRoomIdLowerHandPost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lowerHandRoomsRoomIdLowerHandPost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.lowerHandRoomsRoomIdLowerHandPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Raise Hand
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async raiseHandRoomsRoomIdRaiseHandPost(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.raiseHandRoomsRoomIdRaiseHandPost(roomId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoomsApi.raiseHandRoomsRoomIdRaiseHandPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept Next Raised Hand
         * @param {RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost(requestParameters: RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept User Raised Hand
         * @param {RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost(requestParameters: RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost(requestParameters.roomId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk Get Room By Event Ids
         * @param {RoomsApiBulkGetRoomByEventIdsRoomsBulkGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkGetRoomByEventIdsRoomsBulkGet(requestParameters: RoomsApiBulkGetRoomByEventIdsRoomsBulkGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Room>> {
            return localVarFp.bulkGetRoomByEventIdsRoomsBulkGet(requestParameters.eventIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close Active Rooms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeActiveRoomsRoomsCloseActivePost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.closeActiveRoomsRoomsCloseActivePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Room
         * @param {RoomsApiCreateRoomRoomsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoomRoomsPost(requestParameters: RoomsApiCreateRoomRoomsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRoomOutput> {
            return localVarFp.createRoomRoomsPost(requestParameters.createRoomInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Video Room
         * @param {RoomsApiCreateVideoRoomRoomsVideoRoomPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideoRoomRoomsVideoRoomPost(requestParameters: RoomsApiCreateVideoRoomRoomsVideoRoomPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRoomOutput> {
            return localVarFp.createVideoRoomRoomsVideoRoomPost(requestParameters.createVideoRoomInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Attendee Count
         * @param {RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttendeeCountRoomsRoomIdAttendeesCountGet(requestParameters: RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<AttendeeCountOutput> {
            return localVarFp.getAttendeeCountRoomsRoomIdAttendeesCountGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Next Public Room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextPublicRoomRoomsNextGet(options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.getNextPublicRoomRoomsNextGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Public Rooms Temporal
         * @param {RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicRoomsTemporalRoomsPublicTemporalGet(requestParameters: RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Room>> {
            return localVarFp.getPublicRoomsTemporalRoomsPublicTemporalGet(requestParameters.temporalRelation, requestParameters.experienceTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Raised Hand List
         * @param {RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaisedHandListRoomsRoomIdRaisedHandsGet(requestParameters: RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<RaisedHand>> {
            return localVarFp.getRaisedHandListRoomsRoomIdRaisedHandsGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Room By Experience Type
         * @param {RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet(requestParameters: RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Room>> {
            return localVarFp.getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet(requestParameters.experienceType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Room
         * @param {RoomsApiGetRoomRoomsRoomIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomRoomsRoomIdGet(requestParameters: RoomsApiGetRoomRoomsRoomIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.getRoomRoomsRoomIdGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Room Stats
         * @param {RoomsApiGetRoomStatsRoomsRoomIdStatsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomStatsRoomsRoomIdStatsGet(requestParameters: RoomsApiGetRoomStatsRoomsRoomIdStatsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<RoomStatsOutput> {
            return localVarFp.getRoomStatsRoomsRoomIdStatsGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users On Stage
         * @param {RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersOnStageRoomsRoomIdAttendeesOnStageGet(requestParameters: RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOnStage>> {
            return localVarFp.getUsersOnStageRoomsRoomIdAttendeesOnStageGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join Stage
         * @param {RoomsApiJoinStageRoomsRoomIdJoinStagePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStageRoomsRoomIdJoinStagePost(requestParameters: RoomsApiJoinStageRoomsRoomIdJoinStagePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.joinStageRoomsRoomIdJoinStagePost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join Video Room
         * @param {RoomsApiJoinVideoRoomRoomsJoinPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinVideoRoomRoomsJoinPost(requestParameters: RoomsApiJoinVideoRoomRoomsJoinPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JoinRoomOutput> {
            return localVarFp.joinVideoRoomRoomsJoinPost(requestParameters.joinRoomInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave Room
         * @param {RoomsApiLeaveRoomRoomsLeavePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveRoomRoomsLeavePost(requestParameters: RoomsApiLeaveRoomRoomsLeavePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.leaveRoomRoomsLeavePost(requestParameters.leaveRoomInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave Stage
         * @param {RoomsApiLeaveStageRoomsRoomIdLeaveStagePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveStageRoomsRoomIdLeaveStagePost(requestParameters: RoomsApiLeaveStageRoomsRoomIdLeaveStagePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.leaveStageRoomsRoomIdLeaveStagePost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Room Attendees
         * @param {RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomAttendeesRoomsRoomIdAttendeesGet(requestParameters: RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoomAttendee>> {
            return localVarFp.listRoomAttendeesRoomsRoomIdAttendeesGet(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Rooms By Event Id
         * @param {RoomsApiListRoomsByEventIdRoomsEventsEventIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsByEventIdRoomsEventsEventIdGet(requestParameters: RoomsApiListRoomsByEventIdRoomsEventsEventIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Room>> {
            return localVarFp.listRoomsByEventIdRoomsEventsEventIdGet(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lower Hand
         * @param {RoomsApiLowerHandRoomsRoomIdLowerHandPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lowerHandRoomsRoomIdLowerHandPost(requestParameters: RoomsApiLowerHandRoomsRoomIdLowerHandPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.lowerHandRoomsRoomIdLowerHandPost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Raise Hand
         * @param {RoomsApiRaiseHandRoomsRoomIdRaiseHandPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raiseHandRoomsRoomIdRaiseHandPost(requestParameters: RoomsApiRaiseHandRoomsRoomIdRaiseHandPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.raiseHandRoomsRoomIdRaiseHandPost(requestParameters.roomId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost operation in RoomsApi.
 * @export
 * @interface RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPostRequest
 */
export interface RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost
     */
    readonly roomId: string
}

/**
 * Request parameters for acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost operation in RoomsApi.
 * @export
 * @interface RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPostRequest
 */
export interface RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost
     */
    readonly roomId: string

    /**
     * 
     * @type {string}
     * @memberof RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost
     */
    readonly userId: string
}

/**
 * Request parameters for bulkGetRoomByEventIdsRoomsBulkGet operation in RoomsApi.
 * @export
 * @interface RoomsApiBulkGetRoomByEventIdsRoomsBulkGetRequest
 */
export interface RoomsApiBulkGetRoomByEventIdsRoomsBulkGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RoomsApiBulkGetRoomByEventIdsRoomsBulkGet
     */
    readonly eventIds: Array<string>
}

/**
 * Request parameters for createRoomRoomsPost operation in RoomsApi.
 * @export
 * @interface RoomsApiCreateRoomRoomsPostRequest
 */
export interface RoomsApiCreateRoomRoomsPostRequest {
    /**
     * 
     * @type {CreateRoomInput}
     * @memberof RoomsApiCreateRoomRoomsPost
     */
    readonly createRoomInput: CreateRoomInput
}

/**
 * Request parameters for createVideoRoomRoomsVideoRoomPost operation in RoomsApi.
 * @export
 * @interface RoomsApiCreateVideoRoomRoomsVideoRoomPostRequest
 */
export interface RoomsApiCreateVideoRoomRoomsVideoRoomPostRequest {
    /**
     * 
     * @type {CreateVideoRoomInput}
     * @memberof RoomsApiCreateVideoRoomRoomsVideoRoomPost
     */
    readonly createVideoRoomInput: CreateVideoRoomInput
}

/**
 * Request parameters for getAttendeeCountRoomsRoomIdAttendeesCountGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGetRequest
 */
export interface RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getPublicRoomsTemporalRoomsPublicTemporalGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGetRequest
 */
export interface RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGetRequest {
    /**
     * 
     * @type {TemporalRelation}
     * @memberof RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGet
     */
    readonly temporalRelation: TemporalRelation

    /**
     * 
     * @type {Array<PublicExperienceInput>}
     * @memberof RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGet
     */
    readonly experienceTypes: Array<PublicExperienceInput>
}

/**
 * Request parameters for getRaisedHandListRoomsRoomIdRaisedHandsGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGetRequest
 */
export interface RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGetRequest
 */
export interface RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGetRequest {
    /**
     * 
     * @type {ExperienceType}
     * @memberof RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet
     */
    readonly experienceType: ExperienceType
}

/**
 * Request parameters for getRoomRoomsRoomIdGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetRoomRoomsRoomIdGetRequest
 */
export interface RoomsApiGetRoomRoomsRoomIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiGetRoomRoomsRoomIdGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getRoomStatsRoomsRoomIdStatsGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetRoomStatsRoomsRoomIdStatsGetRequest
 */
export interface RoomsApiGetRoomStatsRoomsRoomIdStatsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiGetRoomStatsRoomsRoomIdStatsGet
     */
    readonly roomId: string
}

/**
 * Request parameters for getUsersOnStageRoomsRoomIdAttendeesOnStageGet operation in RoomsApi.
 * @export
 * @interface RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGetRequest
 */
export interface RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGet
     */
    readonly roomId: string
}

/**
 * Request parameters for joinStageRoomsRoomIdJoinStagePost operation in RoomsApi.
 * @export
 * @interface RoomsApiJoinStageRoomsRoomIdJoinStagePostRequest
 */
export interface RoomsApiJoinStageRoomsRoomIdJoinStagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiJoinStageRoomsRoomIdJoinStagePost
     */
    readonly roomId: string
}

/**
 * Request parameters for joinVideoRoomRoomsJoinPost operation in RoomsApi.
 * @export
 * @interface RoomsApiJoinVideoRoomRoomsJoinPostRequest
 */
export interface RoomsApiJoinVideoRoomRoomsJoinPostRequest {
    /**
     * 
     * @type {JoinRoomInput}
     * @memberof RoomsApiJoinVideoRoomRoomsJoinPost
     */
    readonly joinRoomInput: JoinRoomInput
}

/**
 * Request parameters for leaveRoomRoomsLeavePost operation in RoomsApi.
 * @export
 * @interface RoomsApiLeaveRoomRoomsLeavePostRequest
 */
export interface RoomsApiLeaveRoomRoomsLeavePostRequest {
    /**
     * 
     * @type {LeaveRoomInput}
     * @memberof RoomsApiLeaveRoomRoomsLeavePost
     */
    readonly leaveRoomInput: LeaveRoomInput
}

/**
 * Request parameters for leaveStageRoomsRoomIdLeaveStagePost operation in RoomsApi.
 * @export
 * @interface RoomsApiLeaveStageRoomsRoomIdLeaveStagePostRequest
 */
export interface RoomsApiLeaveStageRoomsRoomIdLeaveStagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiLeaveStageRoomsRoomIdLeaveStagePost
     */
    readonly roomId: string
}

/**
 * Request parameters for listRoomAttendeesRoomsRoomIdAttendeesGet operation in RoomsApi.
 * @export
 * @interface RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGetRequest
 */
export interface RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGet
     */
    readonly roomId: string
}

/**
 * Request parameters for listRoomsByEventIdRoomsEventsEventIdGet operation in RoomsApi.
 * @export
 * @interface RoomsApiListRoomsByEventIdRoomsEventsEventIdGetRequest
 */
export interface RoomsApiListRoomsByEventIdRoomsEventsEventIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiListRoomsByEventIdRoomsEventsEventIdGet
     */
    readonly eventId: string
}

/**
 * Request parameters for lowerHandRoomsRoomIdLowerHandPost operation in RoomsApi.
 * @export
 * @interface RoomsApiLowerHandRoomsRoomIdLowerHandPostRequest
 */
export interface RoomsApiLowerHandRoomsRoomIdLowerHandPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiLowerHandRoomsRoomIdLowerHandPost
     */
    readonly roomId: string
}

/**
 * Request parameters for raiseHandRoomsRoomIdRaiseHandPost operation in RoomsApi.
 * @export
 * @interface RoomsApiRaiseHandRoomsRoomIdRaiseHandPostRequest
 */
export interface RoomsApiRaiseHandRoomsRoomIdRaiseHandPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RoomsApiRaiseHandRoomsRoomIdRaiseHandPost
     */
    readonly roomId: string
}

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * 
     * @summary Accept Next Raised Hand
     * @param {RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost(requestParameters: RoomsApiAcceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).acceptNextRaisedHandRoomsRoomIdAcceptRaisedHandNextPost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept User Raised Hand
     * @param {RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost(requestParameters: RoomsApiAcceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).acceptUserRaisedHandRoomsRoomIdAcceptRaisedHandUserUserIdPost(requestParameters.roomId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk Get Room By Event Ids
     * @param {RoomsApiBulkGetRoomByEventIdsRoomsBulkGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public bulkGetRoomByEventIdsRoomsBulkGet(requestParameters: RoomsApiBulkGetRoomByEventIdsRoomsBulkGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).bulkGetRoomByEventIdsRoomsBulkGet(requestParameters.eventIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close Active Rooms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public closeActiveRoomsRoomsCloseActivePost(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).closeActiveRoomsRoomsCloseActivePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Room
     * @param {RoomsApiCreateRoomRoomsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public createRoomRoomsPost(requestParameters: RoomsApiCreateRoomRoomsPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).createRoomRoomsPost(requestParameters.createRoomInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Video Room
     * @param {RoomsApiCreateVideoRoomRoomsVideoRoomPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public createVideoRoomRoomsVideoRoomPost(requestParameters: RoomsApiCreateVideoRoomRoomsVideoRoomPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).createVideoRoomRoomsVideoRoomPost(requestParameters.createVideoRoomInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Attendee Count
     * @param {RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getAttendeeCountRoomsRoomIdAttendeesCountGet(requestParameters: RoomsApiGetAttendeeCountRoomsRoomIdAttendeesCountGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getAttendeeCountRoomsRoomIdAttendeesCountGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Next Public Room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getNextPublicRoomRoomsNextGet(options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getNextPublicRoomRoomsNextGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Public Rooms Temporal
     * @param {RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getPublicRoomsTemporalRoomsPublicTemporalGet(requestParameters: RoomsApiGetPublicRoomsTemporalRoomsPublicTemporalGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getPublicRoomsTemporalRoomsPublicTemporalGet(requestParameters.temporalRelation, requestParameters.experienceTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Raised Hand List
     * @param {RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRaisedHandListRoomsRoomIdRaisedHandsGet(requestParameters: RoomsApiGetRaisedHandListRoomsRoomIdRaisedHandsGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRaisedHandListRoomsRoomIdRaisedHandsGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Room By Experience Type
     * @param {RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet(requestParameters: RoomsApiGetRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomByExperienceTypeRoomsExperienceTypeExperienceTypeGet(requestParameters.experienceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Room
     * @param {RoomsApiGetRoomRoomsRoomIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomRoomsRoomIdGet(requestParameters: RoomsApiGetRoomRoomsRoomIdGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomRoomsRoomIdGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Room Stats
     * @param {RoomsApiGetRoomStatsRoomsRoomIdStatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomStatsRoomsRoomIdStatsGet(requestParameters: RoomsApiGetRoomStatsRoomsRoomIdStatsGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomStatsRoomsRoomIdStatsGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users On Stage
     * @param {RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getUsersOnStageRoomsRoomIdAttendeesOnStageGet(requestParameters: RoomsApiGetUsersOnStageRoomsRoomIdAttendeesOnStageGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getUsersOnStageRoomsRoomIdAttendeesOnStageGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join Stage
     * @param {RoomsApiJoinStageRoomsRoomIdJoinStagePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public joinStageRoomsRoomIdJoinStagePost(requestParameters: RoomsApiJoinStageRoomsRoomIdJoinStagePostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).joinStageRoomsRoomIdJoinStagePost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join Video Room
     * @param {RoomsApiJoinVideoRoomRoomsJoinPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public joinVideoRoomRoomsJoinPost(requestParameters: RoomsApiJoinVideoRoomRoomsJoinPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).joinVideoRoomRoomsJoinPost(requestParameters.joinRoomInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave Room
     * @param {RoomsApiLeaveRoomRoomsLeavePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public leaveRoomRoomsLeavePost(requestParameters: RoomsApiLeaveRoomRoomsLeavePostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).leaveRoomRoomsLeavePost(requestParameters.leaveRoomInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave Stage
     * @param {RoomsApiLeaveStageRoomsRoomIdLeaveStagePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public leaveStageRoomsRoomIdLeaveStagePost(requestParameters: RoomsApiLeaveStageRoomsRoomIdLeaveStagePostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).leaveStageRoomsRoomIdLeaveStagePost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Room Attendees
     * @param {RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public listRoomAttendeesRoomsRoomIdAttendeesGet(requestParameters: RoomsApiListRoomAttendeesRoomsRoomIdAttendeesGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).listRoomAttendeesRoomsRoomIdAttendeesGet(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Rooms By Event Id
     * @param {RoomsApiListRoomsByEventIdRoomsEventsEventIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public listRoomsByEventIdRoomsEventsEventIdGet(requestParameters: RoomsApiListRoomsByEventIdRoomsEventsEventIdGetRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).listRoomsByEventIdRoomsEventsEventIdGet(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lower Hand
     * @param {RoomsApiLowerHandRoomsRoomIdLowerHandPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public lowerHandRoomsRoomIdLowerHandPost(requestParameters: RoomsApiLowerHandRoomsRoomIdLowerHandPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).lowerHandRoomsRoomIdLowerHandPost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Raise Hand
     * @param {RoomsApiRaiseHandRoomsRoomIdRaiseHandPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public raiseHandRoomsRoomIdRaiseHandPost(requestParameters: RoomsApiRaiseHandRoomsRoomIdRaiseHandPostRequest, options?: RawAxiosRequestConfig) {
        return RoomsApiFp(this.configuration).raiseHandRoomsRoomIdRaiseHandPost(requestParameters.roomId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Health check endpoint for AWS load balancers and monitoring
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Health check endpoint for AWS load balancers and monitoring
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.healthCheckHealthGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Health check endpoint for AWS load balancers and monitoring
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Health check endpoint for AWS load balancers and monitoring
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check In User
         * @param {string} eventId 
         * @param {string} userId 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInUserTicketsEventsEventIdUsersUserIdCheckInPost: async (eventId: string, userId: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('checkInUserTicketsEventsEventIdUsersUserIdCheckInPost', 'eventId', eventId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkInUserTicketsEventsEventIdUsersUserIdCheckInPost', 'userId', userId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('checkInUserTicketsEventsEventIdUsersUserIdCheckInPost', 'token', token)
            const localVarPath = `/tickets/events/{event_id}/users/{user_id}/check-in/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Count tickets for a list of events - admin only endpoint
         * @summary Count Tickets By Events
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countTicketsByEventsTicketsEventsCountPost: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('countTicketsByEventsTicketsEventsCountPost', 'requestBody', requestBody)
            const localVarPath = `/tickets/events/count/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Event Ticket Token
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTicketTokenTicketsEventsEventIdTokenPost: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventTicketTokenTicketsEventsEventIdTokenPost', 'eventId', eventId)
            const localVarPath = `/tickets/events/{event_id}/token/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Ticket
         * @param {CreateTicketInput} createTicketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTicketsPost: async (createTicketInput: CreateTicketInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTicketInput' is not null or undefined
            assertParamExists('createTicketTicketsPost', 'createTicketInput', createTicketInput)
            const localVarPath = `/tickets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTicketInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Ticket Type
         * @param {CreateTicketTypeInput} createTicketTypeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTypeTicketsTypePost: async (createTicketTypeInput: CreateTicketTypeInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTicketTypeInput' is not null or undefined
            assertParamExists('createTicketTypeTicketsTypePost', 'createTicketTypeInput', createTicketTypeInput)
            const localVarPath = `/tickets/type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTicketTypeInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a ticket by ID. Admin-only endpoint.  Args:     request: The HTTP request     ticket_id: The ID of the ticket to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteTicketOutput: Response with ticket_id of the deleted ticket
         * @summary Delete Ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketTicketsTicketIdDelete: async (ticketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('deleteTicketTicketsTicketIdDelete', 'ticketId', ticketId)
            const localVarPath = `/tickets/{ticket_id}/`
                .replace(`{${"ticket_id"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a CSV file with all ticket information for given event_ids and uploads it to S3
         * @summary Export tickets for multiple events as CSV
         * @param {BulkExportTicketsInput} bulkExportTicketsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEventTicketsTicketsEventsExportPost: async (bulkExportTicketsInput: BulkExportTicketsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkExportTicketsInput' is not null or undefined
            assertParamExists('exportEventTicketsTicketsEventsExportPost', 'bulkExportTicketsInput', bulkExportTicketsInput)
            const localVarPath = `/tickets/events/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkExportTicketsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ticket By Token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketByTokenTicketsTokenTokenGet: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getTicketByTokenTicketsTokenTokenGet', 'token', token)
            const localVarPath = `/tickets/token/{token}/`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTicketsTicketIdGet: async (ticketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('getTicketTicketsTicketIdGet', 'ticketId', ticketId)
            const localVarPath = `/tickets/{ticket_id}/`
                .replace(`{${"ticket_id"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ticket Types
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTypesTicketsTypeEventIdGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getTicketTypesTicketsTypeEventIdGet', 'eventId', eventId)
            const localVarPath = `/tickets/type/{event_id}/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tickets By Event Id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketsByEventIdTicketsEventsEventIdGet: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getTicketsByEventIdTicketsEventsEventIdGet', 'eventId', eventId)
            const localVarPath = `/tickets/events/{event_id}/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tickets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketsTicketsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Tickets Temporal
         * @param {TemporalRelation} temporalRelation 
         * @param {string} userId 
         * @param {Array<ExperienceType>} [experienceTypes] Types of experiences to filter tickets by. Virtual types include SUNRISE, PRIVATE_ROOM, and TOPIC. In-person type is IN_PERSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet: async (temporalRelation: TemporalRelation, userId: string, experienceTypes?: Array<ExperienceType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'temporalRelation' is not null or undefined
            assertParamExists('getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet', 'temporalRelation', temporalRelation)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet', 'userId', userId)
            const localVarPath = `/tickets/temporal/{temporal_relation}/users/{user_id}/`
                .replace(`{${"temporal_relation"}}`, encodeURIComponent(String(temporalRelation)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)

            if (experienceTypes) {
                localVarQueryParameter['experience_types'] = experienceTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users Attending Same Event
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet', 'userId', userId)
            const localVarPath = `/tickets/{user_id}/users-at-same-event/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users Overlapping Events
         * @param {string} user1Id 
         * @param {string} user2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersOverlappingEventsTicketsUsersOverlappingEventsGet: async (user1Id: string, user2Id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user1Id' is not null or undefined
            assertParamExists('getUsersOverlappingEventsTicketsUsersOverlappingEventsGet', 'user1Id', user1Id)
            // verify required parameter 'user2Id' is not null or undefined
            assertParamExists('getUsersOverlappingEventsTicketsUsersOverlappingEventsGet', 'user2Id', user2Id)
            const localVarPath = `/tickets/users/overlapping-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)

            if (user1Id !== undefined) {
                localVarQueryParameter['user_1_id'] = user1Id;
            }

            if (user2Id !== undefined) {
                localVarQueryParameter['user_2_id'] = user2Id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ticket Checkout
         * @param {CheckoutInput} checkoutInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketCheckoutTicketsCheckoutPost: async (checkoutInput: CheckoutInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutInput' is not null or undefined
            assertParamExists('ticketCheckoutTicketsCheckoutPost', 'checkoutInput', checkoutInput)
            const localVarPath = `/tickets/checkout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ticket Checkout V2
         * @param {CheckoutInput} checkoutInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketCheckoutV2TicketsCheckoutV2Post: async (checkoutInput: CheckoutInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutInput' is not null or undefined
            assertParamExists('ticketCheckoutV2TicketsCheckoutV2Post', 'checkoutInput', checkoutInput)
            const localVarPath = `/tickets/checkout/v2/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer Ticket
         * @param {TransferTicketInput} transferTicketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferTicketTicketsTransferPost: async (transferTicketInput: TransferTicketInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferTicketInput' is not null or undefined
            assertParamExists('transferTicketTicketsTransferPost', 'transferTicketInput', transferTicketInput)
            const localVarPath = `/tickets/transfer/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferTicketInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undo Check In User
         * @param {string} eventId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost: async (eventId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost', 'eventId', eventId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost', 'userId', userId)
            const localVarPath = `/tickets/events/{event_id}/users/{user_id}/check-in/undo`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin-only endpoint to update the quantity of a ticket.  Args:     payload: The data for updating ticket quantity     current_user: The authenticated admin user     db: Database session      Returns:     GetTicketOutput: The updated ticket
         * @summary Update Ticket Quantity
         * @param {string} ticketId 
         * @param {UpdateTicketQuantityInput} updateTicketQuantityInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketQuantityTicketsTicketIdUpdateQuantityPatch: async (ticketId: string, updateTicketQuantityInput: UpdateTicketQuantityInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('updateTicketQuantityTicketsTicketIdUpdateQuantityPatch', 'ticketId', ticketId)
            // verify required parameter 'updateTicketQuantityInput' is not null or undefined
            assertParamExists('updateTicketQuantityTicketsTicketIdUpdateQuantityPatch', 'updateTicketQuantityInput', updateTicketQuantityInput)
            const localVarPath = `/tickets/{ticket_id}/update-quantity/`
                .replace(`{${"ticket_id"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication Ticket-Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Ticket-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTicketQuantityInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check In User
         * @param {string} eventId 
         * @param {string} userId 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInUserTicketsEventsEventIdUsersUserIdCheckInPost(eventId: string, userId: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInUserTicketsEventsEventIdUsersUserIdCheckInPost(eventId, userId, token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.checkInUserTicketsEventsEventIdUsersUserIdCheckInPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Count tickets for a list of events - admin only endpoint
         * @summary Count Tickets By Events
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countTicketsByEventsTicketsEventsCountPost(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTicketCountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countTicketsByEventsTicketsEventsCountPost(requestBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.countTicketsByEventsTicketsEventsCountPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Event Ticket Token
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTicketTokenTicketsEventsEventIdTokenPost(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTicketTokenOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTicketTokenTicketsEventsEventIdTokenPost(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.createEventTicketTokenTicketsEventsEventIdTokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Ticket
         * @param {CreateTicketInput} createTicketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketTicketsPost(createTicketInput: CreateTicketInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketTicketsPost(createTicketInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.createTicketTicketsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Ticket Type
         * @param {CreateTicketTypeInput} createTicketTypeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketTypeTicketsTypePost(createTicketTypeInput: CreateTicketTypeInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketTypeTicketsTypePost(createTicketTypeInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.createTicketTypeTicketsTypePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a ticket by ID. Admin-only endpoint.  Args:     request: The HTTP request     ticket_id: The ID of the ticket to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteTicketOutput: Response with ticket_id of the deleted ticket
         * @summary Delete Ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicketTicketsTicketIdDelete(ticketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTicketOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicketTicketsTicketIdDelete(ticketId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.deleteTicketTicketsTicketIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Generates a CSV file with all ticket information for given event_ids and uploads it to S3
         * @summary Export tickets for multiple events as CSV
         * @param {BulkExportTicketsInput} bulkExportTicketsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEventTicketsTicketsEventsExportPost(bulkExportTicketsInput: BulkExportTicketsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEventTicketsTicketsEventsExportPost(bulkExportTicketsInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.exportEventTicketsTicketsEventsExportPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Ticket By Token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketByTokenTicketsTokenTokenGet(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketByTokenTicketsTokenTokenGet(token, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getTicketByTokenTicketsTokenTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketTicketsTicketIdGet(ticketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketTicketsTicketIdGet(ticketId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getTicketTicketsTicketIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Ticket Types
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketTypesTicketsTypeEventIdGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketTypesTicketsTypeEventIdGet(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getTicketTypesTicketsTypeEventIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Tickets By Event Id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketsByEventIdTicketsEventsEventIdGet(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTicketOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketsByEventIdTicketsEventsEventIdGet(eventId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getTicketsByEventIdTicketsEventsEventIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Tickets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketsTicketsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketsTicketsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getTicketsTicketsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Tickets Temporal
         * @param {TemporalRelation} temporalRelation 
         * @param {string} userId 
         * @param {Array<ExperienceType>} [experienceTypes] Types of experiences to filter tickets by. Virtual types include SUNRISE, PRIVATE_ROOM, and TOPIC. In-person type is IN_PERSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet(temporalRelation: TemporalRelation, userId: string, experienceTypes?: Array<ExperienceType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTicketOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet(temporalRelation, userId, experienceTypes, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Users Attending Same Event
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersAtSameEventOutput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Users Overlapping Events
         * @param {string} user1Id 
         * @param {string} user2Id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersOverlappingEventsTicketsUsersOverlappingEventsGet(user1Id: string, user2Id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersOverlappingEventsTicketsUsersOverlappingEventsGet(user1Id, user2Id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.getUsersOverlappingEventsTicketsUsersOverlappingEventsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Ticket Checkout
         * @param {CheckoutInput} checkoutInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ticketCheckoutTicketsCheckoutPost(checkoutInput: CheckoutInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ticketCheckoutTicketsCheckoutPost(checkoutInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.ticketCheckoutTicketsCheckoutPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Ticket Checkout V2
         * @param {CheckoutInput} checkoutInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ticketCheckoutV2TicketsCheckoutV2Post(checkoutInput: CheckoutInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ticketCheckoutV2TicketsCheckoutV2Post(checkoutInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.ticketCheckoutV2TicketsCheckoutV2Post']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Transfer Ticket
         * @param {TransferTicketInput} transferTicketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferTicketTicketsTransferPost(transferTicketInput: TransferTicketInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketTransferOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferTicketTicketsTransferPost(transferTicketInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.transferTicketTicketsTransferPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Undo Check In User
         * @param {string} eventId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost(eventId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost(eventId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Admin-only endpoint to update the quantity of a ticket.  Args:     payload: The data for updating ticket quantity     current_user: The authenticated admin user     db: Database session      Returns:     GetTicketOutput: The updated ticket
         * @summary Update Ticket Quantity
         * @param {string} ticketId 
         * @param {UpdateTicketQuantityInput} updateTicketQuantityInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicketQuantityTicketsTicketIdUpdateQuantityPatch(ticketId: string, updateTicketQuantityInput: UpdateTicketQuantityInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTicketQuantityOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicketQuantityTicketsTicketIdUpdateQuantityPatch(ticketId, updateTicketQuantityInput, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TicketsApi.updateTicketQuantityTicketsTicketIdUpdateQuantityPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketsApiFp(configuration)
    return {
        /**
         * 
         * @summary Check In User
         * @param {TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInUserTicketsEventsEventIdUsersUserIdCheckInPost(requestParameters: TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkInUserTicketsEventsEventIdUsersUserIdCheckInPost(requestParameters.eventId, requestParameters.userId, requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Count tickets for a list of events - admin only endpoint
         * @summary Count Tickets By Events
         * @param {TicketsApiCountTicketsByEventsTicketsEventsCountPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countTicketsByEventsTicketsEventsCountPost(requestParameters: TicketsApiCountTicketsByEventsTicketsEventsCountPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<EventTicketCountsResponse> {
            return localVarFp.countTicketsByEventsTicketsEventsCountPost(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Event Ticket Token
         * @param {TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTicketTokenTicketsEventsEventIdTokenPost(requestParameters: TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateTicketTokenOutput> {
            return localVarFp.createEventTicketTokenTicketsEventsEventIdTokenPost(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Ticket
         * @param {TicketsApiCreateTicketTicketsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTicketsPost(requestParameters: TicketsApiCreateTicketTicketsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Ticket> {
            return localVarFp.createTicketTicketsPost(requestParameters.createTicketInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Ticket Type
         * @param {TicketsApiCreateTicketTypeTicketsTypePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTypeTicketsTypePost(requestParameters: TicketsApiCreateTicketTypeTicketsTypePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TicketType> {
            return localVarFp.createTicketTypeTicketsTypePost(requestParameters.createTicketTypeInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a ticket by ID. Admin-only endpoint.  Args:     request: The HTTP request     ticket_id: The ID of the ticket to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteTicketOutput: Response with ticket_id of the deleted ticket
         * @summary Delete Ticket
         * @param {TicketsApiDeleteTicketTicketsTicketIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicketTicketsTicketIdDelete(requestParameters: TicketsApiDeleteTicketTicketsTicketIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteTicketOutput> {
            return localVarFp.deleteTicketTicketsTicketIdDelete(requestParameters.ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a CSV file with all ticket information for given event_ids and uploads it to S3
         * @summary Export tickets for multiple events as CSV
         * @param {TicketsApiExportEventTicketsTicketsEventsExportPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEventTicketsTicketsEventsExportPost(requestParameters: TicketsApiExportEventTicketsTicketsEventsExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TicketExportResponse> {
            return localVarFp.exportEventTicketsTicketsEventsExportPost(requestParameters.bulkExportTicketsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ticket By Token
         * @param {TicketsApiGetTicketByTokenTicketsTokenTokenGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketByTokenTicketsTokenTokenGet(requestParameters: TicketsApiGetTicketByTokenTicketsTokenTokenGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Ticket> {
            return localVarFp.getTicketByTokenTicketsTokenTokenGet(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ticket
         * @param {TicketsApiGetTicketTicketsTicketIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTicketsTicketIdGet(requestParameters: TicketsApiGetTicketTicketsTicketIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicTicket> {
            return localVarFp.getTicketTicketsTicketIdGet(requestParameters.ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ticket Types
         * @param {TicketsApiGetTicketTypesTicketsTypeEventIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTypesTicketsTypeEventIdGet(requestParameters: TicketsApiGetTicketTypesTicketsTypeEventIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TicketType>> {
            return localVarFp.getTicketTypesTicketsTypeEventIdGet(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tickets By Event Id
         * @param {TicketsApiGetTicketsByEventIdTicketsEventsEventIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketsByEventIdTicketsEventsEventIdGet(requestParameters: TicketsApiGetTicketsByEventIdTicketsEventsEventIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTicketOutput>> {
            return localVarFp.getTicketsByEventIdTicketsEventsEventIdGet(requestParameters.eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tickets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketsTicketsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Ticket>> {
            return localVarFp.getTicketsTicketsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Tickets Temporal
         * @param {TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet(requestParameters: TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetTicketOutput>> {
            return localVarFp.getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet(requestParameters.temporalRelation, requestParameters.userId, requestParameters.experienceTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users Attending Same Event
         * @param {TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet(requestParameters: TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UsersAtSameEventOutput>> {
            return localVarFp.getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users Overlapping Events
         * @param {TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersOverlappingEventsTicketsUsersOverlappingEventsGet(requestParameters: TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getUsersOverlappingEventsTicketsUsersOverlappingEventsGet(requestParameters.user1Id, requestParameters.user2Id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ticket Checkout
         * @param {TicketsApiTicketCheckoutTicketsCheckoutPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketCheckoutTicketsCheckoutPost(requestParameters: TicketsApiTicketCheckoutTicketsCheckoutPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ticketCheckoutTicketsCheckoutPost(requestParameters.checkoutInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ticket Checkout V2
         * @param {TicketsApiTicketCheckoutV2TicketsCheckoutV2PostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketCheckoutV2TicketsCheckoutV2Post(requestParameters: TicketsApiTicketCheckoutV2TicketsCheckoutV2PostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ticketCheckoutV2TicketsCheckoutV2Post(requestParameters.checkoutInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer Ticket
         * @param {TicketsApiTransferTicketTicketsTransferPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferTicketTicketsTransferPost(requestParameters: TicketsApiTransferTicketTicketsTransferPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TicketTransferOutput> {
            return localVarFp.transferTicketTicketsTransferPost(requestParameters.transferTicketInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undo Check In User
         * @param {TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost(requestParameters: TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost(requestParameters.eventId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin-only endpoint to update the quantity of a ticket.  Args:     payload: The data for updating ticket quantity     current_user: The authenticated admin user     db: Database session      Returns:     GetTicketOutput: The updated ticket
         * @summary Update Ticket Quantity
         * @param {TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketQuantityTicketsTicketIdUpdateQuantityPatch(requestParameters: TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateTicketQuantityOutput> {
            return localVarFp.updateTicketQuantityTicketsTicketIdUpdateQuantityPatch(requestParameters.ticketId, requestParameters.updateTicketQuantityInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkInUserTicketsEventsEventIdUsersUserIdCheckInPost operation in TicketsApi.
 * @export
 * @interface TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPostRequest
 */
export interface TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPost
     */
    readonly eventId: string

    /**
     * 
     * @type {string}
     * @memberof TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPost
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPost
     */
    readonly token: string
}

/**
 * Request parameters for countTicketsByEventsTicketsEventsCountPost operation in TicketsApi.
 * @export
 * @interface TicketsApiCountTicketsByEventsTicketsEventsCountPostRequest
 */
export interface TicketsApiCountTicketsByEventsTicketsEventsCountPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TicketsApiCountTicketsByEventsTicketsEventsCountPost
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for createEventTicketTokenTicketsEventsEventIdTokenPost operation in TicketsApi.
 * @export
 * @interface TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPostRequest
 */
export interface TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPost
     */
    readonly eventId: string
}

/**
 * Request parameters for createTicketTicketsPost operation in TicketsApi.
 * @export
 * @interface TicketsApiCreateTicketTicketsPostRequest
 */
export interface TicketsApiCreateTicketTicketsPostRequest {
    /**
     * 
     * @type {CreateTicketInput}
     * @memberof TicketsApiCreateTicketTicketsPost
     */
    readonly createTicketInput: CreateTicketInput
}

/**
 * Request parameters for createTicketTypeTicketsTypePost operation in TicketsApi.
 * @export
 * @interface TicketsApiCreateTicketTypeTicketsTypePostRequest
 */
export interface TicketsApiCreateTicketTypeTicketsTypePostRequest {
    /**
     * 
     * @type {CreateTicketTypeInput}
     * @memberof TicketsApiCreateTicketTypeTicketsTypePost
     */
    readonly createTicketTypeInput: CreateTicketTypeInput
}

/**
 * Request parameters for deleteTicketTicketsTicketIdDelete operation in TicketsApi.
 * @export
 * @interface TicketsApiDeleteTicketTicketsTicketIdDeleteRequest
 */
export interface TicketsApiDeleteTicketTicketsTicketIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiDeleteTicketTicketsTicketIdDelete
     */
    readonly ticketId: string
}

/**
 * Request parameters for exportEventTicketsTicketsEventsExportPost operation in TicketsApi.
 * @export
 * @interface TicketsApiExportEventTicketsTicketsEventsExportPostRequest
 */
export interface TicketsApiExportEventTicketsTicketsEventsExportPostRequest {
    /**
     * 
     * @type {BulkExportTicketsInput}
     * @memberof TicketsApiExportEventTicketsTicketsEventsExportPost
     */
    readonly bulkExportTicketsInput: BulkExportTicketsInput
}

/**
 * Request parameters for getTicketByTokenTicketsTokenTokenGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetTicketByTokenTicketsTokenTokenGetRequest
 */
export interface TicketsApiGetTicketByTokenTicketsTokenTokenGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetTicketByTokenTicketsTokenTokenGet
     */
    readonly token: string
}

/**
 * Request parameters for getTicketTicketsTicketIdGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetTicketTicketsTicketIdGetRequest
 */
export interface TicketsApiGetTicketTicketsTicketIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetTicketTicketsTicketIdGet
     */
    readonly ticketId: string
}

/**
 * Request parameters for getTicketTypesTicketsTypeEventIdGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetTicketTypesTicketsTypeEventIdGetRequest
 */
export interface TicketsApiGetTicketTypesTicketsTypeEventIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetTicketTypesTicketsTypeEventIdGet
     */
    readonly eventId: string
}

/**
 * Request parameters for getTicketsByEventIdTicketsEventsEventIdGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetTicketsByEventIdTicketsEventsEventIdGetRequest
 */
export interface TicketsApiGetTicketsByEventIdTicketsEventsEventIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetTicketsByEventIdTicketsEventsEventIdGet
     */
    readonly eventId: string
}

/**
 * Request parameters for getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGetRequest
 */
export interface TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGetRequest {
    /**
     * 
     * @type {TemporalRelation}
     * @memberof TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet
     */
    readonly temporalRelation: TemporalRelation

    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet
     */
    readonly userId: string

    /**
     * Types of experiences to filter tickets by. Virtual types include SUNRISE, PRIVATE_ROOM, and TOPIC. In-person type is IN_PERSON.
     * @type {Array<ExperienceType>}
     * @memberof TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet
     */
    readonly experienceTypes?: Array<ExperienceType>
}

/**
 * Request parameters for getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGetRequest
 */
export interface TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet
     */
    readonly userId: string
}

/**
 * Request parameters for getUsersOverlappingEventsTicketsUsersOverlappingEventsGet operation in TicketsApi.
 * @export
 * @interface TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGetRequest
 */
export interface TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGet
     */
    readonly user1Id: string

    /**
     * 
     * @type {string}
     * @memberof TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGet
     */
    readonly user2Id: string
}

/**
 * Request parameters for ticketCheckoutTicketsCheckoutPost operation in TicketsApi.
 * @export
 * @interface TicketsApiTicketCheckoutTicketsCheckoutPostRequest
 */
export interface TicketsApiTicketCheckoutTicketsCheckoutPostRequest {
    /**
     * 
     * @type {CheckoutInput}
     * @memberof TicketsApiTicketCheckoutTicketsCheckoutPost
     */
    readonly checkoutInput: CheckoutInput
}

/**
 * Request parameters for ticketCheckoutV2TicketsCheckoutV2Post operation in TicketsApi.
 * @export
 * @interface TicketsApiTicketCheckoutV2TicketsCheckoutV2PostRequest
 */
export interface TicketsApiTicketCheckoutV2TicketsCheckoutV2PostRequest {
    /**
     * 
     * @type {CheckoutInput}
     * @memberof TicketsApiTicketCheckoutV2TicketsCheckoutV2Post
     */
    readonly checkoutInput: CheckoutInput
}

/**
 * Request parameters for transferTicketTicketsTransferPost operation in TicketsApi.
 * @export
 * @interface TicketsApiTransferTicketTicketsTransferPostRequest
 */
export interface TicketsApiTransferTicketTicketsTransferPostRequest {
    /**
     * 
     * @type {TransferTicketInput}
     * @memberof TicketsApiTransferTicketTicketsTransferPost
     */
    readonly transferTicketInput: TransferTicketInput
}

/**
 * Request parameters for undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost operation in TicketsApi.
 * @export
 * @interface TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPostRequest
 */
export interface TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost
     */
    readonly eventId: string

    /**
     * 
     * @type {string}
     * @memberof TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost
     */
    readonly userId: string
}

/**
 * Request parameters for updateTicketQuantityTicketsTicketIdUpdateQuantityPatch operation in TicketsApi.
 * @export
 * @interface TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatchRequest
 */
export interface TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatch
     */
    readonly ticketId: string

    /**
     * 
     * @type {UpdateTicketQuantityInput}
     * @memberof TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatch
     */
    readonly updateTicketQuantityInput: UpdateTicketQuantityInput
}

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
    /**
     * 
     * @summary Check In User
     * @param {TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public checkInUserTicketsEventsEventIdUsersUserIdCheckInPost(requestParameters: TicketsApiCheckInUserTicketsEventsEventIdUsersUserIdCheckInPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).checkInUserTicketsEventsEventIdUsersUserIdCheckInPost(requestParameters.eventId, requestParameters.userId, requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Count tickets for a list of events - admin only endpoint
     * @summary Count Tickets By Events
     * @param {TicketsApiCountTicketsByEventsTicketsEventsCountPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public countTicketsByEventsTicketsEventsCountPost(requestParameters: TicketsApiCountTicketsByEventsTicketsEventsCountPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).countTicketsByEventsTicketsEventsCountPost(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Event Ticket Token
     * @param {TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public createEventTicketTokenTicketsEventsEventIdTokenPost(requestParameters: TicketsApiCreateEventTicketTokenTicketsEventsEventIdTokenPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).createEventTicketTokenTicketsEventsEventIdTokenPost(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Ticket
     * @param {TicketsApiCreateTicketTicketsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public createTicketTicketsPost(requestParameters: TicketsApiCreateTicketTicketsPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).createTicketTicketsPost(requestParameters.createTicketInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Ticket Type
     * @param {TicketsApiCreateTicketTypeTicketsTypePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public createTicketTypeTicketsTypePost(requestParameters: TicketsApiCreateTicketTypeTicketsTypePostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).createTicketTypeTicketsTypePost(requestParameters.createTicketTypeInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a ticket by ID. Admin-only endpoint.  Args:     request: The HTTP request     ticket_id: The ID of the ticket to delete     current_user: The authenticated admin user\'s JWT payload     db: Database session      Returns:     DeleteTicketOutput: Response with ticket_id of the deleted ticket
     * @summary Delete Ticket
     * @param {TicketsApiDeleteTicketTicketsTicketIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public deleteTicketTicketsTicketIdDelete(requestParameters: TicketsApiDeleteTicketTicketsTicketIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).deleteTicketTicketsTicketIdDelete(requestParameters.ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a CSV file with all ticket information for given event_ids and uploads it to S3
     * @summary Export tickets for multiple events as CSV
     * @param {TicketsApiExportEventTicketsTicketsEventsExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public exportEventTicketsTicketsEventsExportPost(requestParameters: TicketsApiExportEventTicketsTicketsEventsExportPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).exportEventTicketsTicketsEventsExportPost(requestParameters.bulkExportTicketsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ticket By Token
     * @param {TicketsApiGetTicketByTokenTicketsTokenTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicketByTokenTicketsTokenTokenGet(requestParameters: TicketsApiGetTicketByTokenTicketsTokenTokenGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicketByTokenTicketsTokenTokenGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ticket
     * @param {TicketsApiGetTicketTicketsTicketIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicketTicketsTicketIdGet(requestParameters: TicketsApiGetTicketTicketsTicketIdGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicketTicketsTicketIdGet(requestParameters.ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ticket Types
     * @param {TicketsApiGetTicketTypesTicketsTypeEventIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicketTypesTicketsTypeEventIdGet(requestParameters: TicketsApiGetTicketTypesTicketsTypeEventIdGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicketTypesTicketsTypeEventIdGet(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tickets By Event Id
     * @param {TicketsApiGetTicketsByEventIdTicketsEventsEventIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicketsByEventIdTicketsEventsEventIdGet(requestParameters: TicketsApiGetTicketsByEventIdTicketsEventsEventIdGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicketsByEventIdTicketsEventsEventIdGet(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tickets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getTicketsTicketsGet(options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getTicketsTicketsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Tickets Temporal
     * @param {TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet(requestParameters: TicketsApiGetUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getUserTicketsTemporalTicketsTemporalTemporalRelationUsersUserIdGet(requestParameters.temporalRelation, requestParameters.userId, requestParameters.experienceTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users Attending Same Event
     * @param {TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet(requestParameters: TicketsApiGetUsersAttendingSameEventTicketsUserIdUsersAtSameEventGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getUsersAttendingSameEventTicketsUserIdUsersAtSameEventGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users Overlapping Events
     * @param {TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getUsersOverlappingEventsTicketsUsersOverlappingEventsGet(requestParameters: TicketsApiGetUsersOverlappingEventsTicketsUsersOverlappingEventsGetRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getUsersOverlappingEventsTicketsUsersOverlappingEventsGet(requestParameters.user1Id, requestParameters.user2Id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ticket Checkout
     * @param {TicketsApiTicketCheckoutTicketsCheckoutPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public ticketCheckoutTicketsCheckoutPost(requestParameters: TicketsApiTicketCheckoutTicketsCheckoutPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).ticketCheckoutTicketsCheckoutPost(requestParameters.checkoutInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ticket Checkout V2
     * @param {TicketsApiTicketCheckoutV2TicketsCheckoutV2PostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public ticketCheckoutV2TicketsCheckoutV2Post(requestParameters: TicketsApiTicketCheckoutV2TicketsCheckoutV2PostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).ticketCheckoutV2TicketsCheckoutV2Post(requestParameters.checkoutInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer Ticket
     * @param {TicketsApiTransferTicketTicketsTransferPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public transferTicketTicketsTransferPost(requestParameters: TicketsApiTransferTicketTicketsTransferPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).transferTicketTicketsTransferPost(requestParameters.transferTicketInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undo Check In User
     * @param {TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost(requestParameters: TicketsApiUndoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPostRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).undoCheckInUserTicketsEventsEventIdUsersUserIdCheckInUndoPost(requestParameters.eventId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin-only endpoint to update the quantity of a ticket.  Args:     payload: The data for updating ticket quantity     current_user: The authenticated admin user     db: Database session      Returns:     GetTicketOutput: The updated ticket
     * @summary Update Ticket Quantity
     * @param {TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public updateTicketQuantityTicketsTicketIdUpdateQuantityPatch(requestParameters: TicketsApiUpdateTicketQuantityTicketsTicketIdUpdateQuantityPatchRequest, options?: RawAxiosRequestConfig) {
        return TicketsApiFp(this.configuration).updateTicketQuantityTicketsTicketIdUpdateQuantityPatch(requestParameters.ticketId, requestParameters.updateTicketQuantityInput, options).then((request) => request(this.axios, this.basePath));
    }
}



